/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/main.ts
__export(exports, {
  default: () => AITaggerPlugin
});
var import_obsidian2 = __toModule(require("obsidian"));

// src/services/types.ts
var ConnectionTestResult;
(function(ConnectionTestResult2) {
  ConnectionTestResult2["Success"] = "success";
  ConnectionTestResult2["Failed"] = "failed";
})(ConnectionTestResult || (ConnectionTestResult = {}));

// src/services/baseService.ts
var BaseLLMService = class {
  constructor(config) {
    this.endpoint = config.endpoint.trim();
    this.modelName = config.modelName.trim();
  }
  validateConfig() {
    if (!this.endpoint) {
      return "API endpoint is not configured";
    }
    if (!this.modelName) {
      return "Model name is not configured";
    }
    try {
      new URL(this.endpoint);
    } catch (e) {
      return "Invalid API endpoint URL format";
    }
    return null;
  }
  validateTag(tag) {
    const tagRegex = /^#[a-zA-Z0-9-]+$/;
    return tagRegex.test(tag);
  }
  validateTags(tags) {
    const validatedTags = [];
    const errors = [];
    for (const tag of tags) {
      if (!this.validateTag(tag)) {
        errors.push(`Invalid tag format: ${tag}`);
        continue;
      }
      validatedTags.push(tag);
    }
    if (errors.length > 0) {
      throw new Error(`Tag validation errors:
${errors.join("\n")}`);
    }
    if (validatedTags.length === 0) {
      throw new Error("No valid tags found in response");
    }
    return validatedTags;
  }
  extractJSONFromResponse(response) {
    console.log("Raw response:", response);
    const markdownJsonRegex = /```(?:json)?\s*(\{[\s\S]*?\})\s*```/;
    const markdownMatch = response.match(markdownJsonRegex);
    if (markdownMatch) {
      console.log("Found JSON in markdown block:", markdownMatch[1]);
      return markdownMatch[1];
    }
    const jsonRegex = /\{[\s\S]*\}/;
    const jsonMatch = response.match(jsonRegex);
    if (jsonMatch) {
      console.log("Found standalone JSON:", jsonMatch[0]);
      return jsonMatch[0];
    }
    throw new Error("No valid JSON found in response");
  }
  buildPrompt(content, existingTags) {
    return `Analyze the following content and:
1. Match 1-3 most relevant tags from existing tags
2. Generate 3-10 new relevant tags

Requirements for tags:
- Must start with # symbol
- Can only contain letters, numbers, and hyphens
- No spaces allowed
- Example format: #technology, #artificial-intelligence, #coding

Existing tags:
${existingTags.join(", ")}

Content:
${content}

Return only a JSON object in this exact format:
{
    "matchedTags": ["#tag1", "#tag2"],
    "newTags": ["#tag1", "#tag2", "#tag3"]
}`;
  }
  parseResponse(response) {
    try {
      console.log("Attempting to parse response...");
      const jsonContent = this.extractJSONFromResponse(response);
      console.log("Extracted JSON content:", jsonContent);
      const parsed = JSON.parse(jsonContent);
      console.log("Parsed JSON:", parsed);
      if (!parsed.matchedTags || !Array.isArray(parsed.matchedTags) || !parsed.newTags || !Array.isArray(parsed.newTags)) {
        console.error("Invalid response structure:", parsed);
        throw new Error("Response missing required fields");
      }
      const validatedMatchedTags = this.validateTags(parsed.matchedTags);
      const validatedNewTags = this.validateTags(parsed.newTags);
      const uniqueTags = new Set([...validatedMatchedTags, ...validatedNewTags]);
      return {
        matchedExistingTags: validatedMatchedTags,
        suggestedTags: Array.from(new Set(validatedNewTags))
      };
    } catch (error) {
      console.error("Error parsing response:", error);
      console.error("Raw response:", response);
      if (error instanceof Error) {
        throw new Error(`Invalid response format: ${error.message}`);
      }
      throw new Error("Invalid response format");
    }
  }
  handleError(error, operation) {
    console.error(`Error in ${operation}:`, error);
    if (error instanceof Error) {
      if (error.name === "AbortError") {
        throw new Error(`Operation timed out: ${operation}`);
      }
      throw new Error(`${operation} failed: ${error.message}`);
    }
    throw error;
  }
};

// src/services/localService.ts
var LocalLLMService = class extends BaseLLMService {
  constructor(config) {
    super(config);
    this.endpoint = this.normalizeEndpoint(config.endpoint);
  }
  normalizeEndpoint(endpoint) {
    endpoint = endpoint.trim();
    endpoint = endpoint.replace(/\/$/, "");
    if (endpoint.endsWith("/api/generate")) {
      endpoint = endpoint.replace("/api/generate", "/v1/chat/completions");
    }
    if (!endpoint.endsWith("/v1/chat/completions")) {
      endpoint = `${endpoint}/v1/chat/completions`;
    }
    return endpoint;
  }
  validateLocalConfig() {
    const baseError = this.validateConfig();
    if (baseError)
      return baseError;
    try {
      const url = new URL(this.endpoint);
      if (!url.pathname.endsWith("/v1/chat/completions")) {
        return "Invalid endpoint format. Should end with /v1/chat/completions";
      }
    } catch (e) {
      return "Invalid endpoint URL format";
    }
    return null;
  }
  async testConnection() {
    try {
      const validationError = this.validateLocalConfig();
      if (validationError) {
        return {
          result: ConnectionTestResult.Failed,
          error: {
            type: "network",
            message: validationError
          }
        };
      }
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 1e4);
      console.log("Testing local LLM connection with endpoint:", this.endpoint);
      const response = await fetch(this.endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: this.modelName,
          messages: [{
            role: "user",
            content: "Test connection"
          }],
          max_tokens: 5
        }),
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      const responseText = await response.text();
      console.log("Local LLM test response:", responseText);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      try {
        const data = JSON.parse(responseText);
        if (!data.choices || !Array.isArray(data.choices)) {
          throw new Error("Invalid response format");
        }
      } catch (parseError) {
        console.error("Parse error:", parseError);
        throw new Error("Invalid response format");
      }
      return { result: ConnectionTestResult.Success };
    } catch (error) {
      console.error("Local LLM connection test error:", error);
      let testError = {
        type: "unknown",
        message: "Unknown error"
      };
      if (error instanceof Error) {
        if (error.name === "AbortError") {
          testError = {
            type: "timeout",
            message: "Connection timeout, please check if the local LLM service is running"
          };
        } else if (error.message.includes("Failed to fetch")) {
          testError = {
            type: "network",
            message: "Network error, please check if the local service is accessible"
          };
        } else if (error.message.includes("HTTP error")) {
          testError = {
            type: "network",
            message: `Service error: ${error.message}`
          };
        } else if (error.message.includes("Invalid response")) {
          testError = {
            type: "unknown",
            message: "Invalid response format from local service"
          };
        }
      }
      return {
        result: ConnectionTestResult.Failed,
        error: testError
      };
    }
  }
  async analyzeTags(content, existingTags) {
    var _a, _b, _c;
    try {
      const validationError = this.validateLocalConfig();
      if (validationError) {
        throw new Error(validationError);
      }
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 3e4);
      const response = await fetch(this.endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: this.modelName,
          messages: [
            {
              role: "system",
              content: "You are a professional document tag analysis assistant. You need to analyze content and suggest relevant tags."
            },
            {
              role: "user",
              content: this.buildPrompt(content, existingTags)
            }
          ],
          temperature: 0.3
        }),
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      const responseText = await response.text();
      console.log("Local LLM response:", responseText);
      if (!response.ok) {
        throw new Error(`API error: ${response.status} ${response.statusText}`);
      }
      try {
        const data = JSON.parse(responseText);
        const textToAnalyze = (_c = (_b = (_a = data.choices) == null ? void 0 : _a[0]) == null ? void 0 : _b.message) == null ? void 0 : _c.content;
        if (!textToAnalyze) {
          throw new Error("Missing response content");
        }
        return this.parseResponse(textToAnalyze);
      } catch (parseError) {
        console.error("Parse error:", parseError, "Response:", responseText);
        throw new Error("Invalid response format from local service");
      }
    } catch (error) {
      return this.handleError(error, "Tag analysis");
    }
  }
};

// src/services/cloudService.ts
var CloudLLMService = class extends BaseLLMService {
  constructor(config) {
    super(config);
    var _a;
    this.apiKey = ((_a = config.apiKey) == null ? void 0 : _a.trim()) || "";
  }
  validateCloudConfig() {
    const baseError = this.validateConfig();
    if (baseError)
      return baseError;
    if (!this.apiKey) {
      return "API key is not configured";
    }
    if (!this.endpoint.toLowerCase().includes("/chat/completions")) {
      return "Cloud API endpoint should include '/chat/completions'";
    }
    return null;
  }
  async testConnection() {
    var _a;
    try {
      const validationError = this.validateCloudConfig();
      if (validationError) {
        return {
          result: ConnectionTestResult.Failed,
          error: {
            type: "network",
            message: validationError
          }
        };
      }
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 1e4);
      console.log("Testing connection with endpoint:", this.endpoint);
      const response = await fetch(this.endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.apiKey}`
        },
        body: JSON.stringify({
          model: this.modelName,
          messages: [
            {
              role: "system",
              content: "Connection test"
            }
          ],
          max_tokens: 5
        }),
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      const responseText = await response.text();
      console.log("Cloud API test response:", responseText);
      if (!response.ok) {
        if (response.status === 401) {
          throw new Error("Authentication failed: Invalid API key");
        } else if (response.status === 404) {
          throw new Error("API endpoint not found: Please verify the URL");
        }
        try {
          const errorJson = JSON.parse(responseText);
          throw new Error(((_a = errorJson.error) == null ? void 0 : _a.message) || errorJson.message || `HTTP error ${response.status}`);
        } catch (e) {
          throw new Error(`HTTP error ${response.status}: ${responseText}`);
        }
      }
      const data = JSON.parse(responseText);
      if (!data.choices || !Array.isArray(data.choices)) {
        throw new Error("Invalid API response format: missing choices array");
      }
      return { result: ConnectionTestResult.Success };
    } catch (error) {
      let testError = {
        type: "unknown",
        message: "Unknown error occurred during connection test"
      };
      if (error instanceof Error) {
        if (error.name === "AbortError") {
          testError = {
            type: "timeout",
            message: "Connection timeout: Please check your network status"
          };
        } else if (error.message.includes("Failed to fetch")) {
          testError = {
            type: "network",
            message: "Network error: Unable to reach the API endpoint"
          };
        } else if (error.message.includes("Authentication failed")) {
          testError = {
            type: "auth",
            message: "Authentication failed: Please verify your API key"
          };
        } else if (error.message.includes("API endpoint not found")) {
          testError = {
            type: "network",
            message: "API endpoint not found: Please verify the URL"
          };
        } else {
          testError = {
            type: "unknown",
            message: `Error: ${error.message}`
          };
        }
      }
      console.error("Cloud API test error:", error);
      return {
        result: ConnectionTestResult.Failed,
        error: testError
      };
    }
  }
  async analyzeTags(content, existingTags) {
    var _a, _b, _c;
    try {
      const validationError = this.validateCloudConfig();
      if (validationError) {
        throw new Error(validationError);
      }
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 3e4);
      const response = await fetch(this.endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.apiKey}`
        },
        body: JSON.stringify({
          model: this.modelName,
          messages: [
            {
              role: "system",
              content: "You are a professional document tag analysis assistant. You need to analyze document content, match relevant tags from existing ones, and generate new relevant tags."
            },
            {
              role: "user",
              content: this.buildPrompt(content, existingTags)
            }
          ]
        }),
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      const responseText = await response.text();
      console.log("Cloud API response:", responseText);
      if (!response.ok) {
        try {
          const errorJson = JSON.parse(responseText);
          throw new Error(((_a = errorJson.error) == null ? void 0 : _a.message) || errorJson.message || `API error: ${response.status}`);
        } catch (e) {
          throw new Error(`API error: ${response.status} ${response.statusText}`);
        }
      }
      const data = JSON.parse(responseText);
      if (!data.choices || !((_c = (_b = data.choices[0]) == null ? void 0 : _b.message) == null ? void 0 : _c.content)) {
        throw new Error("Invalid API response format: missing message content");
      }
      return this.parseResponse(data.choices[0].message.content);
    } catch (error) {
      return this.handleError(error, "Tag analysis");
    }
  }
};

// src/tagUtils.ts
var import_obsidian = __toModule(require("obsidian"));
var TagUtils = class {
  static validateTag(tag) {
    const tagRegex = /^#[a-zA-Z0-9-]+$/;
    return tagRegex.test(tag);
  }
  static validateTags(tags) {
    const valid = [];
    const invalid = [];
    for (const tag of tags) {
      if (this.validateTag(tag)) {
        valid.push(tag);
      } else {
        invalid.push(tag);
      }
    }
    return { valid, invalid };
  }
  static getExistingTags(frontmatter) {
    if (!frontmatter || !frontmatter.tags) {
      return [];
    }
    let tags = [];
    if (Array.isArray(frontmatter.tags)) {
      tags = frontmatter.tags;
    } else if (typeof frontmatter.tags === "string") {
      tags = [frontmatter.tags];
    }
    const { valid, invalid } = this.validateTags(tags);
    if (invalid.length > 0) {
      console.warn("Found invalid tags in frontmatter:", invalid);
    }
    return valid;
  }
  static mergeTags(existingTags, newTags) {
    const { valid: validExisting } = this.validateTags(existingTags);
    const { valid: validNew } = this.validateTags(newTags);
    const allTags = [...validExisting, ...validNew];
    return [...new Set(allTags)].sort();
  }
  static formatTag(tag) {
    tag = tag.trim();
    const formattedTag = tag.startsWith("#") ? tag : `#${tag}`;
    if (!this.validateTag(formattedTag)) {
      throw new Error(`Invalid tag format: ${tag} (can only contain letters, numbers, and hyphens)`);
    }
    return formattedTag;
  }
  static async clearTags(app, file) {
    try {
      const content = await app.vault.read(file);
      if (!content.startsWith("---\n")) {
        return {
          success: false,
          message: "No frontmatter found in the note"
        };
      }
      const endOfFrontMatter = content.indexOf("---\n", 4);
      if (endOfFrontMatter === -1) {
        return {
          success: false,
          message: "Invalid frontmatter format"
        };
      }
      const frontMatter = content.slice(4, endOfFrontMatter);
      const afterFrontMatter = content.slice(endOfFrontMatter);
      const lines = frontMatter.split("\n");
      const newLines = [];
      let inTagsBlock = false;
      let tagsFound = false;
      for (const line of lines) {
        if (line.trim().startsWith("tags:")) {
          tagsFound = true;
          newLines.push("tags:");
          inTagsBlock = true;
          continue;
        }
        if (inTagsBlock) {
          if (line.trim().startsWith("-") || line.trim().startsWith("  -")) {
            continue;
          } else {
            inTagsBlock = false;
          }
        }
        if (!inTagsBlock) {
          newLines.push(line);
        }
      }
      if (!tagsFound) {
        newLines.push("tags:");
      }
      const newContent = `---
${newLines.join("\n")}${afterFrontMatter}`;
      await app.vault.modify(file, newContent);
      await app.metadataCache.trigger("changed", file);
      await new Promise((resolve) => setTimeout(resolve, 100));
      app.workspace.trigger("file-open", file);
      return {
        success: true,
        message: "Successfully cleared all tags",
        tags: []
      };
    } catch (error) {
      console.error("Error clearing tags:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      new import_obsidian.Notice("Error clearing tags");
      return {
        success: false,
        message: `Failed to clear tags: ${errorMessage}`
      };
    }
  }
  static async updateNoteTags(app, file, newTags, matchedTags) {
    var _a;
    try {
      const { valid: validNewTags, invalid: invalidNewTags } = this.validateTags(newTags);
      const { valid: validMatchedTags, invalid: invalidMatchedTags } = this.validateTags(matchedTags);
      if (invalidNewTags.length > 0 || invalidMatchedTags.length > 0) {
        const invalidTags = [...invalidNewTags, ...invalidMatchedTags];
        throw new Error(`Invalid tag format found: ${invalidTags.join(", ")}
Tags can only contain letters, numbers, and hyphens`);
      }
      const content = await app.vault.read(file);
      const frontmatter = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      const existingTags = this.getExistingTags(frontmatter);
      const allTags = this.mergeTags(existingTags, [...validNewTags, ...validMatchedTags]).map((tag) => tag.startsWith("#") ? tag.substring(1) : tag);
      let newContent = content;
      const yamlTags = allTags.map((tag) => `  - ${tag}`).join("\n");
      if (content.startsWith("---\n")) {
        const endOfFrontMatter = content.indexOf("---\n", 4);
        if (endOfFrontMatter !== -1) {
          const beforeFrontMatter = content.slice(0, endOfFrontMatter);
          const afterFrontMatter = content.slice(endOfFrontMatter);
          if (beforeFrontMatter.includes("\ntags:")) {
            const tagsRegex = /\ntags:.*?(?=\n[^\s]|\n---)/s;
            newContent = beforeFrontMatter.replace(tagsRegex, `
tags:
${yamlTags}`) + afterFrontMatter;
          } else {
            newContent = beforeFrontMatter + `
tags:
${yamlTags}` + afterFrontMatter;
          }
        }
      } else {
        newContent = `---
tags:
${yamlTags}
---

${content}`;
      }
      await app.vault.modify(file, newContent);
      await app.metadataCache.trigger("changed", file);
      await new Promise((resolve) => setTimeout(resolve, 100));
      app.workspace.trigger("file-open", file);
      return {
        success: true,
        message: `Successfully updated tags: ${validNewTags.length} new tags added, ${validMatchedTags.length} existing tags matched`,
        tags: allTags.map((tag) => `#${tag}`)
      };
    } catch (error) {
      console.error("Error updating note tags:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      new import_obsidian.Notice("Error updating tags");
      return {
        success: false,
        message: `Failed to update tags: ${errorMessage}`
      };
    }
  }
  static getAllTags(app) {
    const tags = new Set();
    app.metadataCache.getCachedFiles().forEach((filePath) => {
      var _a;
      const cache = app.metadataCache.getCache(filePath);
      if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.tags) {
        const fileTags = this.getExistingTags(cache.frontmatter);
        fileTags.forEach((tag) => tags.add(tag));
      }
    });
    return Array.from(tags).sort();
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  serviceType: "local",
  localEndpoint: "http://localhost:11434",
  localModel: "llama2",
  cloudEndpoint: "https://api.openai.com/v1/chat/completions",
  cloudApiKey: "",
  cloudModel: "gpt-3.5-turbo",
  maxNewTags: 5,
  maxMatchedTags: 2
};
var AITaggerPlugin = class extends import_obsidian2.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.settings = DEFAULT_SETTINGS;
    this.llmService = new LocalLLMService({
      endpoint: DEFAULT_SETTINGS.localEndpoint,
      modelName: DEFAULT_SETTINGS.localModel
    });
  }
  async onload() {
    await this.loadSettings();
    this.initializeLLMService();
    this.addSettingTab(new AITaggerSettingTab(this.app, this));
    this.addCommand({
      id: "analyze-note-and-add-tags",
      name: "Analyze Current Note and Add Tags",
      callback: () => this.analyzeCurrentNote()
    });
    this.addCommand({
      id: "clear-all-tags",
      name: "Clear All Tags (Keep Tags Field)",
      hotkeys: [{ modifiers: ["Mod", "Shift"], key: "T" }],
      callback: () => this.clearNoteTags()
    });
    this.loadStyles();
  }
  loadStyles() {
    const css = document.createElement("style");
    css.id = "ai-tagger-styles";
    css.textContent = `
        .connection-test-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .connection-test-status {
            margin-left: 10px;
            display: inline-flex;
            align-items: center;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .connection-test-status.success {
            color: var(--color-green);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .connection-test-status.error {
            color: var(--color-red);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .connection-test-status.testing {
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .connection-test-status.success::before {
            content: "\u2713";
            font-weight: bold;
        }

        .connection-test-status.error::before {
            content: "\u2717";
            font-weight: bold;
        }

        .connection-test-status.testing::after {
            content: "";
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid var(--text-muted);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .endpoint-description code {
            background-color: var(--background-modifier-form-control);
            padding: 2px 4px;
            border-radius: 4px;
            font-family: var(--font-monospace);
        }

        .support-container {
            margin-top: 1rem;
            padding: 1rem;
            border-radius: 8px;
            background: var(--background-primary-alt);
            text-align: center;
        }

        .support-button {
            margin-top: 1rem;
            background-color: #FF813F !important;
            color: white !important;
        }

        .support-button:hover {
            background-color: #FF9B66 !important;
        }`;
    document.head.appendChild(css);
  }
  initializeLLMService() {
    const config = {
      endpoint: this.settings.serviceType === "local" ? this.settings.localEndpoint : this.settings.cloudEndpoint,
      apiKey: this.settings.cloudApiKey,
      modelName: this.settings.serviceType === "local" ? this.settings.localModel : this.settings.cloudModel
    };
    this.llmService = this.settings.serviceType === "local" ? new LocalLLMService(config) : new CloudLLMService(config);
  }
  async loadSettings() {
    const oldSettings = await this.loadData();
    if (oldSettings && oldSettings.serviceType === "ollama") {
      oldSettings.serviceType = "local";
      oldSettings.localEndpoint = oldSettings.ollamaEndpoint;
      oldSettings.localModel = oldSettings.ollamaModel;
      delete oldSettings.ollamaEndpoint;
      delete oldSettings.ollamaModel;
    }
    this.settings = Object.assign({}, DEFAULT_SETTINGS, oldSettings);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.initializeLLMService();
  }
  async testConnection() {
    return this.llmService.testConnection();
  }
  async clearNoteTags() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian2.Notice("Please open a note first");
      return;
    }
    try {
      const result = await TagUtils.clearTags(this.app, activeFile);
      if (result.success) {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
        if ((view == null ? void 0 : view.getMode()) === "source") {
          view.editor.refresh();
        }
        this.app.vault.trigger("modify", activeFile);
        new import_obsidian2.Notice("Successfully cleared all tags");
      } else {
        new import_obsidian2.Notice(result.message);
      }
      setTimeout(() => {
        this.app.workspace.trigger("file-open", activeFile);
      }, 150);
    } catch (error) {
      console.error("Error clearing tags:", error);
      const message = error instanceof Error ? error.message : "Unknown error";
      new import_obsidian2.Notice(`Error clearing tags: ${message}`);
    }
  }
  async analyzeCurrentNote() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian2.Notice("Please open a note first");
      return;
    }
    try {
      const content = await this.app.vault.read(activeFile);
      if (!content.trim()) {
        new import_obsidian2.Notice("Note is empty");
        return;
      }
      const existingTags = TagUtils.getAllTags(this.app);
      new import_obsidian2.Notice("Analyzing note content...");
      console.log("Starting tag analysis with:", {
        serviceType: this.settings.serviceType,
        contentLength: content.length,
        existingTagsCount: existingTags.length
      });
      const analysis = await this.llmService.analyzeTags(content, existingTags);
      const result = await TagUtils.updateNoteTags(this.app, activeFile, analysis.suggestedTags.slice(0, this.settings.maxNewTags), analysis.matchedExistingTags.slice(0, this.settings.maxMatchedTags));
      if (result.success) {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
        if ((view == null ? void 0 : view.getMode()) === "source") {
          view.editor.refresh();
        }
        new import_obsidian2.Notice(result.message);
      } else {
        new import_obsidian2.Notice("Failed to update tags");
      }
    } catch (error) {
      console.error("Error in analyzeCurrentNote:", error);
      const message = error instanceof Error ? error.message : "Unknown error";
      new import_obsidian2.Notice(`Error analyzing note: ${message}`);
    }
  }
  onunload() {
    const style = document.getElementById("ai-tagger-styles");
    if (style) {
      style.remove();
    }
  }
};
var AITaggerSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.testButton = null;
    this.statusEl = null;
    this.statusContainer = null;
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("AI Service Type").setDesc("Choose the AI service provider to use").addDropdown((dropdown) => dropdown.addOptions({
      "local": "Local LLM Service",
      "cloud": "Cloud Service"
    }).setValue(this.plugin.settings.serviceType).onChange(async (value) => {
      this.plugin.settings.serviceType = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.serviceType === "local") {
      this.displayLocalSettings(containerEl);
    } else {
      this.displayCloudSettings(containerEl);
    }
    this.displayGeneralSettings(containerEl);
  }
  setTestStatus(status, message) {
    if (!this.statusContainer || !this.statusEl)
      return;
    this.statusContainer.removeClass("testing", "success", "error");
    this.statusContainer.addClass(status);
    switch (status) {
      case "testing":
        this.statusEl.setText("Testing...");
        break;
      case "success":
        this.statusEl.setText(message || "Connection successful");
        break;
      case "error":
        this.statusEl.setText(message || "Connection failed");
        break;
    }
  }
  createTestButton(containerEl) {
    const testContainer = containerEl.createDiv("connection-test-container");
    const testSetting = new import_obsidian2.Setting(testContainer).setName("Connection Test").setDesc("Test connection to AI service");
    const buttonContainer = testSetting.settingEl.createDiv("setting-item-control");
    const button = new import_obsidian2.ButtonComponent(buttonContainer).setButtonText("Test Connection").onClick(async () => {
      var _a;
      button.setButtonText("Testing...").setDisabled(true);
      this.setTestStatus("testing");
      try {
        const result = await this.plugin.testConnection();
        if (result.result === ConnectionTestResult.Success) {
          this.setTestStatus("success", "Connection successful");
        } else {
          this.setTestStatus("error", ((_a = result.error) == null ? void 0 : _a.message) || "Connection failed");
        }
      } catch (error) {
        console.error("Test connection error:", error);
        this.setTestStatus("error", "Error during test");
      } finally {
        button.setButtonText("Test Connection").setDisabled(false);
      }
    });
    this.statusContainer = testContainer.createDiv("connection-test-status");
    this.statusEl = this.statusContainer.createSpan();
    this.testButton = button;
  }
  displayLocalSettings(containerEl) {
    const info = containerEl.createDiv();
    info.createSpan({
      text: "Base URL address of your local LLM service.",
      cls: "setting-item-description"
    });
    info.createEl("br");
    info.createEl("br");
    info.createSpan({
      text: "All services will use the OpenAI-compatible /v1/chat/completions endpoint:",
      cls: "setting-item-description"
    });
    const list = info.createEl("ul", { cls: "setting-item-description" });
    const ollamaItem = list.createEl("li");
    ollamaItem.createSpan({ text: "Ollama - Enter base URL: " });
    ollamaItem.createEl("code", { text: "http://localhost:11434" });
    ollamaItem.createEl("br");
    ollamaItem.createSpan({
      text: "(Will be converted to /v1/chat/completions format)",
      cls: "setting-item-description"
    });
    const lmStudioItem = list.createEl("li");
    lmStudioItem.createSpan({ text: "LM Studio: " });
    lmStudioItem.createEl("code", { text: "http://localhost:1234/v1/chat/completions" });
    const localAIItem = list.createEl("li");
    localAIItem.createSpan({ text: "LocalAI: " });
    localAIItem.createEl("code", { text: "http://localhost:8080/v1/chat/completions" });
    new import_obsidian2.Setting(containerEl).setName("Local LLM Endpoint").setDesc("Enter the base URL for your local service").addText((text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.localEndpoint).onChange(async (value) => {
      this.plugin.settings.localEndpoint = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Model Name").setDesc("Name of the model to use with your local service").addText((text) => text.setPlaceholder("llama2").setValue(this.plugin.settings.localModel).onChange(async (value) => {
      this.plugin.settings.localModel = value;
      await this.plugin.saveSettings();
    }));
    this.createTestButton(containerEl);
  }
  displayCloudSettings(containerEl) {
    const description = createFragment((descEl) => {
      descEl.appendText("Complete chat completions API endpoint URL.");
      descEl.createEl("br");
      descEl.appendText("For example, OpenAI's endpoint:");
      descEl.createEl("br");
      descEl.createEl("code", {
        text: "https://api.openai.com/v1/chat/completions",
        cls: "endpoint-description"
      });
    });
    new import_obsidian2.Setting(containerEl).setName("API Endpoint").setDesc(description).addText((text) => text.setPlaceholder("https://api.openai.com/v1/chat/completions").setValue(this.plugin.settings.cloudEndpoint).onChange(async (value) => {
      this.plugin.settings.cloudEndpoint = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("API Key").setDesc("Cloud service API key").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.cloudApiKey).onChange(async (value) => {
      this.plugin.settings.cloudApiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Model Name").setDesc("Name of model to use").addText((text) => text.setPlaceholder("gpt-3.5-turbo").setValue(this.plugin.settings.cloudModel).onChange(async (value) => {
      this.plugin.settings.cloudModel = value;
      await this.plugin.saveSettings();
    }));
    this.createTestButton(containerEl);
  }
  displayGeneralSettings(containerEl) {
    new import_obsidian2.Setting(containerEl).setName("Maximum New Tags").setDesc("Maximum number of new tags to generate (3-10)").addSlider((slider) => slider.setLimits(3, 10, 1).setValue(this.plugin.settings.maxNewTags).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxNewTags = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Maximum Matched Tags").setDesc("Maximum number of tags to match from existing ones (1-3)").addSlider((slider) => slider.setLimits(1, 3, 1).setValue(this.plugin.settings.maxMatchedTags).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxMatchedTags = value;
      await this.plugin.saveSettings();
      containerEl.createEl("h2", { text: "\u652F\u6301\u5F00\u53D1\u8005" });
      const supportEl = containerEl.createDiv("support-container");
      supportEl.createSpan({ text: "\u5982\u679C\u4F60\u89C9\u5F97\u8FD9\u4E2A\u63D2\u4EF6\u5BF9\u4F60\u6709\u5E2E\u52A9\uFF0C\u53EF\u4EE5\u8003\u8651\u7ED9\u6211\u4E70\u676F\u5496\u5561 \u2615\uFE0F" });
      const button = new import_obsidian2.ButtonComponent(supportEl).setButtonText("Buy Me a Coffee").setClass("support-button").onClick(() => {
        window.open("https://buymeacoffee.com/niehu2015o", "_blank");
      });
    }));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL3NlcnZpY2VzL3R5cGVzLnRzIiwgInNyYy9zZXJ2aWNlcy9iYXNlU2VydmljZS50cyIsICJzcmMvc2VydmljZXMvbG9jYWxTZXJ2aWNlLnRzIiwgInNyYy9zZXJ2aWNlcy9jbG91ZFNlcnZpY2UudHMiLCAic3JjL3RhZ1V0aWxzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBQbHVnaW4sIE5vdGljZSwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgVEZpbGUsIEFwcCwgQnV0dG9uQ29tcG9uZW50LCBNYXJrZG93blZpZXcsIEVkaXRvciB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IExMTVNlcnZpY2UsIExvY2FsTExNU2VydmljZSwgQ2xvdWRMTE1TZXJ2aWNlLCBDb25uZWN0aW9uVGVzdFJlc3VsdCwgTExNU2VydmljZUNvbmZpZyB9IGZyb20gJy4vc2VydmljZXMnO1xuaW1wb3J0IHsgVGFnVXRpbHMsIFRhZ09wZXJhdGlvblJlc3VsdCB9IGZyb20gJy4vdGFnVXRpbHMnO1xuXG5pbnRlcmZhY2UgQUlUYWdnZXJTZXR0aW5ncyB7XG4gICAgc2VydmljZVR5cGU6ICdsb2NhbCcgfCAnY2xvdWQnO1xuICAgIGxvY2FsRW5kcG9pbnQ6IHN0cmluZztcbiAgICBsb2NhbE1vZGVsOiBzdHJpbmc7XG4gICAgY2xvdWRFbmRwb2ludDogc3RyaW5nO1xuICAgIGNsb3VkQXBpS2V5OiBzdHJpbmc7XG4gICAgY2xvdWRNb2RlbDogc3RyaW5nO1xuICAgIG1heE5ld1RhZ3M6IG51bWJlcjtcbiAgICBtYXhNYXRjaGVkVGFnczogbnVtYmVyO1xufVxuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBBSVRhZ2dlclNldHRpbmdzID0ge1xuICAgIHNlcnZpY2VUeXBlOiAnbG9jYWwnLFxuICAgIGxvY2FsRW5kcG9pbnQ6ICdodHRwOi8vbG9jYWxob3N0OjExNDM0JywgIC8vIEJhc2UgZW5kcG9pbnRcbiAgICBsb2NhbE1vZGVsOiAnbGxhbWEyJyxcbiAgICBjbG91ZEVuZHBvaW50OiAnaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MS9jaGF0L2NvbXBsZXRpb25zJyxcbiAgICBjbG91ZEFwaUtleTogJycsXG4gICAgY2xvdWRNb2RlbDogJ2dwdC0zLjUtdHVyYm8nLFxuICAgIG1heE5ld1RhZ3M6IDUsXG4gICAgbWF4TWF0Y2hlZFRhZ3M6IDJcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFJVGFnZ2VyUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBzZXR0aW5nczogQUlUYWdnZXJTZXR0aW5ncyA9IERFRkFVTFRfU0VUVElOR1M7XG4gICAgcHJpdmF0ZSBsbG1TZXJ2aWNlOiBMTE1TZXJ2aWNlO1xuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIG1hbmlmZXN0OiBhbnkpIHtcbiAgICAgICAgc3VwZXIoYXBwLCBtYW5pZmVzdCk7XG4gICAgICAgIHRoaXMubGxtU2VydmljZSA9IG5ldyBMb2NhbExMTVNlcnZpY2Uoe1xuICAgICAgICAgICAgZW5kcG9pbnQ6IERFRkFVTFRfU0VUVElOR1MubG9jYWxFbmRwb2ludCxcbiAgICAgICAgICAgIG1vZGVsTmFtZTogREVGQVVMVF9TRVRUSU5HUy5sb2NhbE1vZGVsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIG9ubG9hZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplTExNU2VydmljZSgpO1xuXG4gICAgICAgIC8vIEFkZCBzZXR0aW5ncyB0YWJcbiAgICAgICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBBSVRhZ2dlclNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcblxuICAgICAgICAvLyBBZGQgY29tbWFuZHNcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiAnYW5hbHl6ZS1ub3RlLWFuZC1hZGQtdGFncycsXG4gICAgICAgICAgICBuYW1lOiAnQW5hbHl6ZSBDdXJyZW50IE5vdGUgYW5kIEFkZCBUYWdzJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB0aGlzLmFuYWx5emVDdXJyZW50Tm90ZSgpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogJ2NsZWFyLWFsbC10YWdzJyxcbiAgICAgICAgICAgIG5hbWU6ICdDbGVhciBBbGwgVGFncyAoS2VlcCBUYWdzIEZpZWxkKScsXG4gICAgICAgICAgICBob3RrZXlzOiBbeyBtb2RpZmllcnM6IFsnTW9kJywgJ1NoaWZ0J10sIGtleTogJ1QnIH1dLFxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMuY2xlYXJOb3RlVGFncygpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIExvYWQgQ1NTXG4gICAgICAgIHRoaXMubG9hZFN0eWxlcygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgbG9hZFN0eWxlcygpIHtcbiAgICAgICAgY29uc3QgY3NzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgY3NzLmlkID0gJ2FpLXRhZ2dlci1zdHlsZXMnO1xuICAgICAgICBjc3MudGV4dENvbnRlbnQgPSBgXG4gICAgICAgIC5jb25uZWN0aW9uLXRlc3QtY29udGFpbmVyIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgZ2FwOiA4cHg7XG4gICAgICAgIH1cblxuICAgICAgICAuY29ubmVjdGlvbi10ZXN0LXN0YXR1cyB7XG4gICAgICAgICAgICBtYXJnaW4tbGVmdDogMTBweDtcbiAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgIHBhZGRpbmc6IDRweCA4cHg7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICAgICAgICBmb250LXNpemU6IDAuOWVtO1xuICAgICAgICB9XG5cbiAgICAgICAgLmNvbm5lY3Rpb24tdGVzdC1zdGF0dXMuc3VjY2VzcyB7XG4gICAgICAgICAgICBjb2xvcjogdmFyKC0tY29sb3ItZ3JlZW4pO1xuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICBnYXA6IDRweDtcbiAgICAgICAgfVxuXG4gICAgICAgIC5jb25uZWN0aW9uLXRlc3Qtc3RhdHVzLmVycm9yIHtcbiAgICAgICAgICAgIGNvbG9yOiB2YXIoLS1jb2xvci1yZWQpO1xuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICBnYXA6IDRweDtcbiAgICAgICAgfVxuXG4gICAgICAgIC5jb25uZWN0aW9uLXRlc3Qtc3RhdHVzLnRlc3Rpbmcge1xuICAgICAgICAgICAgY29sb3I6IHZhcigtLXRleHQtbXV0ZWQpO1xuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICBnYXA6IDRweDtcbiAgICAgICAgfVxuXG4gICAgICAgIC5jb25uZWN0aW9uLXRlc3Qtc3RhdHVzLnN1Y2Nlc3M6OmJlZm9yZSB7XG4gICAgICAgICAgICBjb250ZW50OiBcIlx1MjcxM1wiO1xuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIH1cblxuICAgICAgICAuY29ubmVjdGlvbi10ZXN0LXN0YXR1cy5lcnJvcjo6YmVmb3JlIHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiXHUyNzE3XCI7XG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC5jb25uZWN0aW9uLXRlc3Qtc3RhdHVzLnRlc3Rpbmc6OmFmdGVyIHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCI7XG4gICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgICAgICB3aWR0aDogMTJweDtcbiAgICAgICAgICAgIGhlaWdodDogMTJweDtcbiAgICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHZhcigtLXRleHQtbXV0ZWQpO1xuICAgICAgICAgICAgYm9yZGVyLXRvcC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgICAgICBhbmltYXRpb246IHNwaW4gMXMgbGluZWFyIGluZmluaXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgQGtleWZyYW1lcyBzcGluIHtcbiAgICAgICAgICAgIHRvIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLmVuZHBvaW50LWRlc2NyaXB0aW9uIGNvZGUge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1mb3JtLWNvbnRyb2wpO1xuICAgICAgICAgICAgcGFkZGluZzogMnB4IDRweDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LW1vbm9zcGFjZSk7XG4gICAgICAgIH1cblxuICAgICAgICAuc3VwcG9ydC1jb250YWluZXIge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMXJlbTtcbiAgICAgICAgICAgIHBhZGRpbmc6IDFyZW07XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1iYWNrZ3JvdW5kLXByaW1hcnktYWx0KTtcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC5zdXBwb3J0LWJ1dHRvbiB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAxcmVtO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGODEzRiAhaW1wb3J0YW50O1xuICAgICAgICAgICAgY29sb3I6IHdoaXRlICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAuc3VwcG9ydC1idXR0b246aG92ZXIge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGOUI2NiAhaW1wb3J0YW50O1xuICAgICAgICB9YDtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChjc3MpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaW5pdGlhbGl6ZUxMTVNlcnZpY2UoKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZzogTExNU2VydmljZUNvbmZpZyA9IHtcbiAgICAgICAgICAgIGVuZHBvaW50OiB0aGlzLnNldHRpbmdzLnNlcnZpY2VUeXBlID09PSAnbG9jYWwnIFxuICAgICAgICAgICAgICAgID8gdGhpcy5zZXR0aW5ncy5sb2NhbEVuZHBvaW50IFxuICAgICAgICAgICAgICAgIDogdGhpcy5zZXR0aW5ncy5jbG91ZEVuZHBvaW50LFxuICAgICAgICAgICAgYXBpS2V5OiB0aGlzLnNldHRpbmdzLmNsb3VkQXBpS2V5LFxuICAgICAgICAgICAgbW9kZWxOYW1lOiB0aGlzLnNldHRpbmdzLnNlcnZpY2VUeXBlID09PSAnbG9jYWwnXG4gICAgICAgICAgICAgICAgPyB0aGlzLnNldHRpbmdzLmxvY2FsTW9kZWxcbiAgICAgICAgICAgICAgICA6IHRoaXMuc2V0dGluZ3MuY2xvdWRNb2RlbFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMubGxtU2VydmljZSA9IHRoaXMuc2V0dGluZ3Muc2VydmljZVR5cGUgPT09ICdsb2NhbCdcbiAgICAgICAgICAgID8gbmV3IExvY2FsTExNU2VydmljZShjb25maWcpXG4gICAgICAgICAgICA6IG5ldyBDbG91ZExMTVNlcnZpY2UoY29uZmlnKTtcbiAgICB9XG5cbiAgICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG4gICAgICAgIGNvbnN0IG9sZFNldHRpbmdzID0gYXdhaXQgdGhpcy5sb2FkRGF0YSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gSGFuZGxlIG1pZ3JhdGlvbiBmcm9tIG9sZCBzZXR0aW5nc1xuICAgICAgICBpZiAob2xkU2V0dGluZ3MgJiYgb2xkU2V0dGluZ3Muc2VydmljZVR5cGUgPT09ICdvbGxhbWEnKSB7XG4gICAgICAgICAgICBvbGRTZXR0aW5ncy5zZXJ2aWNlVHlwZSA9ICdsb2NhbCc7XG4gICAgICAgICAgICBvbGRTZXR0aW5ncy5sb2NhbEVuZHBvaW50ID0gb2xkU2V0dGluZ3Mub2xsYW1hRW5kcG9pbnQ7XG4gICAgICAgICAgICBvbGRTZXR0aW5ncy5sb2NhbE1vZGVsID0gb2xkU2V0dGluZ3Mub2xsYW1hTW9kZWw7XG4gICAgICAgICAgICBkZWxldGUgb2xkU2V0dGluZ3Mub2xsYW1hRW5kcG9pbnQ7XG4gICAgICAgICAgICBkZWxldGUgb2xkU2V0dGluZ3Mub2xsYW1hTW9kZWw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgb2xkU2V0dGluZ3MpO1xuICAgIH1cblxuICAgIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplTExNU2VydmljZSgpO1xuICAgIH1cblxuICAgIGFzeW5jIHRlc3RDb25uZWN0aW9uKCk6IFByb21pc2U8eyByZXN1bHQ6IENvbm5lY3Rpb25UZXN0UmVzdWx0OyBlcnJvcj86IGFueSB9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmxsbVNlcnZpY2UudGVzdENvbm5lY3Rpb24oKTtcbiAgICB9XG5cbiAgICBhc3luYyBjbGVhck5vdGVUYWdzKCkge1xuICAgICAgICBjb25zdCBhY3RpdmVGaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICAgICAgaWYgKCFhY3RpdmVGaWxlKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKCdQbGVhc2Ugb3BlbiBhIG5vdGUgZmlyc3QnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBUYWdVdGlscy5jbGVhclRhZ3ModGhpcy5hcHAsIGFjdGl2ZUZpbGUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXc/LmdldE1vZGUoKSA9PT0gJ3NvdXJjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5lZGl0b3IucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC52YXVsdC50cmlnZ2VyKCdtb2RpZnknLCBhY3RpdmVGaWxlKTtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdTdWNjZXNzZnVsbHkgY2xlYXJlZCBhbGwgdGFncycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKHJlc3VsdC5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRW5zdXJlIHZpZXcgaXMgdXBkYXRlZFxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLnRyaWdnZXIoJ2ZpbGUtb3BlbicsIGFjdGl2ZUZpbGUpO1xuICAgICAgICAgICAgfSwgMTUwKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNsZWFyaW5nIHRhZ3M6JywgZXJyb3IpO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InO1xuICAgICAgICAgICAgbmV3IE5vdGljZShgRXJyb3IgY2xlYXJpbmcgdGFnczogJHttZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgYW5hbHl6ZUN1cnJlbnROb3RlKCkge1xuICAgICAgICBjb25zdCBhY3RpdmVGaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICAgICAgaWYgKCFhY3RpdmVGaWxlKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKCdQbGVhc2Ugb3BlbiBhIG5vdGUgZmlyc3QnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChhY3RpdmVGaWxlKTtcbiAgICAgICAgICAgIGlmICghY29udGVudC50cmltKCkpIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdOb3RlIGlzIGVtcHR5Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1RhZ3MgPSBUYWdVdGlscy5nZXRBbGxUYWdzKHRoaXMuYXBwKTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0FuYWx5emluZyBub3RlIGNvbnRlbnQuLi4nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIHRhZyBhbmFseXNpcyB3aXRoOicsIHtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlVHlwZTogdGhpcy5zZXR0aW5ncy5zZXJ2aWNlVHlwZSxcbiAgICAgICAgICAgICAgICBjb250ZW50TGVuZ3RoOiBjb250ZW50Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICBleGlzdGluZ1RhZ3NDb3VudDogZXhpc3RpbmdUYWdzLmxlbmd0aFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFuYWx5c2lzID0gYXdhaXQgdGhpcy5sbG1TZXJ2aWNlLmFuYWx5emVUYWdzKGNvbnRlbnQsIGV4aXN0aW5nVGFncyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBUYWdVdGlscy51cGRhdGVOb3RlVGFncyhcbiAgICAgICAgICAgICAgICB0aGlzLmFwcCxcbiAgICAgICAgICAgICAgICBhY3RpdmVGaWxlLFxuICAgICAgICAgICAgICAgIGFuYWx5c2lzLnN1Z2dlc3RlZFRhZ3Muc2xpY2UoMCwgdGhpcy5zZXR0aW5ncy5tYXhOZXdUYWdzKSxcbiAgICAgICAgICAgICAgICBhbmFseXNpcy5tYXRjaGVkRXhpc3RpbmdUYWdzLnNsaWNlKDAsIHRoaXMuc2V0dGluZ3MubWF4TWF0Y2hlZFRhZ3MpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcbiAgICAgICAgICAgICAgICBpZiAodmlldz8uZ2V0TW9kZSgpID09PSAnc291cmNlJykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmVkaXRvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UocmVzdWx0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdGYWlsZWQgdG8gdXBkYXRlIHRhZ3MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGFuYWx5emVDdXJyZW50Tm90ZTonLCBlcnJvcik7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcic7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBFcnJvciBhbmFseXppbmcgbm90ZTogJHttZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb251bmxvYWQoKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FpLXRhZ2dlci1zdHlsZXMnKTtcbiAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICBzdHlsZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQUlUYWdnZXJTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gICAgcGx1Z2luOiBBSVRhZ2dlclBsdWdpbjtcbiAgICBwcml2YXRlIHRlc3RCdXR0b246IEJ1dHRvbkNvbXBvbmVudCB8IG51bGwgPSBudWxsO1xuICAgIHByaXZhdGUgc3RhdHVzRWw6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBzdGF0dXNDb250YWluZXI6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG5cbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBBSVRhZ2dlclBsdWdpbikge1xuICAgICAgICBzdXBlcihhcHAsIHBsdWdpbik7XG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgIH1cblxuICAgIGRpc3BsYXkoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnQUkgU2VydmljZSBUeXBlJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdDaG9vc2UgdGhlIEFJIHNlcnZpY2UgcHJvdmlkZXIgdG8gdXNlJylcbiAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiBcbiAgICAgICAgICAgICAgICBkcm9wZG93blxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbG9jYWwnOiAnTG9jYWwgTExNIFNlcnZpY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Nsb3VkJzogJ0Nsb3VkIFNlcnZpY2UnXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZXJ2aWNlVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VydmljZVR5cGUgPSB2YWx1ZSBhcyAnbG9jYWwnIHwgJ2Nsb3VkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZXJ2aWNlVHlwZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5TG9jYWxTZXR0aW5ncyhjb250YWluZXJFbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlDbG91ZFNldHRpbmdzKGNvbnRhaW5lckVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlzcGxheUdlbmVyYWxTZXR0aW5ncyhjb250YWluZXJFbCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRUZXN0U3RhdHVzKHN0YXR1czogJ3Rlc3RpbmcnIHwgJ3N1Y2Nlc3MnIHwgJ2Vycm9yJywgbWVzc2FnZT86IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdHVzQ29udGFpbmVyIHx8ICF0aGlzLnN0YXR1c0VsKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5zdGF0dXNDb250YWluZXIucmVtb3ZlQ2xhc3MoJ3Rlc3RpbmcnLCAnc3VjY2VzcycsICdlcnJvcicpO1xuICAgICAgICB0aGlzLnN0YXR1c0NvbnRhaW5lci5hZGRDbGFzcyhzdGF0dXMpO1xuICAgICAgICBcbiAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3Rlc3RpbmcnOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzRWwuc2V0VGV4dCgnVGVzdGluZy4uLicpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3VjY2Vzcyc6XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNFbC5zZXRUZXh0KG1lc3NhZ2UgfHwgJ0Nvbm5lY3Rpb24gc3VjY2Vzc2Z1bCcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzRWwuc2V0VGV4dChtZXNzYWdlIHx8ICdDb25uZWN0aW9uIGZhaWxlZCcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVUZXN0QnV0dG9uKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgICBjb25zdCB0ZXN0Q29udGFpbmVyID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KCdjb25uZWN0aW9uLXRlc3QtY29udGFpbmVyJyk7XG5cbiAgICAgICAgY29uc3QgdGVzdFNldHRpbmcgPSBuZXcgU2V0dGluZyh0ZXN0Q29udGFpbmVyKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0Nvbm5lY3Rpb24gVGVzdCcpXG4gICAgICAgICAgICAuc2V0RGVzYygnVGVzdCBjb25uZWN0aW9uIHRvIEFJIHNlcnZpY2UnKTtcblxuICAgICAgICBjb25zdCBidXR0b25Db250YWluZXIgPSB0ZXN0U2V0dGluZy5zZXR0aW5nRWwuY3JlYXRlRGl2KCdzZXR0aW5nLWl0ZW0tY29udHJvbCcpO1xuICAgICAgICBjb25zdCBidXR0b24gPSBuZXcgQnV0dG9uQ29tcG9uZW50KGJ1dHRvbkNvbnRhaW5lcilcbiAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdUZXN0IENvbm5lY3Rpb24nKVxuICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KCdUZXN0aW5nLi4uJykuc2V0RGlzYWJsZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUZXN0U3RhdHVzKCd0ZXN0aW5nJyk7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnBsdWdpbi50ZXN0Q29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdCA9PT0gQ29ubmVjdGlvblRlc3RSZXN1bHQuU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUZXN0U3RhdHVzKCdzdWNjZXNzJywgJ0Nvbm5lY3Rpb24gc3VjY2Vzc2Z1bCcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUZXN0U3RhdHVzKCdlcnJvcicsIHJlc3VsdC5lcnJvcj8ubWVzc2FnZSB8fCAnQ29ubmVjdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rlc3QgY29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VGVzdFN0YXR1cygnZXJyb3InLCAnRXJyb3IgZHVyaW5nIHRlc3QnKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dCgnVGVzdCBDb25uZWN0aW9uJykuc2V0RGlzYWJsZWQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc3RhdHVzQ29udGFpbmVyID0gdGVzdENvbnRhaW5lci5jcmVhdGVEaXYoJ2Nvbm5lY3Rpb24tdGVzdC1zdGF0dXMnKTtcbiAgICAgICAgdGhpcy5zdGF0dXNFbCA9IHRoaXMuc3RhdHVzQ29udGFpbmVyLmNyZWF0ZVNwYW4oKTtcbiAgICAgICAgdGhpcy50ZXN0QnV0dG9uID0gYnV0dG9uO1xuICAgIH1cblxuICAgIHByaXZhdGUgZGlzcGxheUxvY2FsU2V0dGluZ3MoY29udGFpbmVyRWw6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGluZm8gPSBjb250YWluZXJFbC5jcmVhdGVEaXYoKTtcbiAgICAgICAgaW5mby5jcmVhdGVTcGFuKHtcbiAgICAgICAgICAgIHRleHQ6ICdCYXNlIFVSTCBhZGRyZXNzIG9mIHlvdXIgbG9jYWwgTExNIHNlcnZpY2UuJyxcbiAgICAgICAgICAgIGNsczogJ3NldHRpbmctaXRlbS1kZXNjcmlwdGlvbidcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpbmZvLmNyZWF0ZUVsKCdicicpO1xuICAgICAgICBpbmZvLmNyZWF0ZUVsKCdicicpO1xuXG4gICAgICAgIGluZm8uY3JlYXRlU3Bhbih7XG4gICAgICAgICAgICB0ZXh0OiAnQWxsIHNlcnZpY2VzIHdpbGwgdXNlIHRoZSBPcGVuQUktY29tcGF0aWJsZSAvdjEvY2hhdC9jb21wbGV0aW9ucyBlbmRwb2ludDonLFxuICAgICAgICAgICAgY2xzOiAnc2V0dGluZy1pdGVtLWRlc2NyaXB0aW9uJ1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBsaXN0ID0gaW5mby5jcmVhdGVFbCgndWwnLCB7IGNsczogJ3NldHRpbmctaXRlbS1kZXNjcmlwdGlvbicgfSk7XG5cbiAgICAgICAgLy8gT2xsYW1hIGV4YW1wbGVcbiAgICAgICAgY29uc3Qgb2xsYW1hSXRlbSA9IGxpc3QuY3JlYXRlRWwoJ2xpJyk7XG4gICAgICAgIG9sbGFtYUl0ZW0uY3JlYXRlU3Bhbih7IHRleHQ6ICdPbGxhbWEgLSBFbnRlciBiYXNlIFVSTDogJyB9KTtcbiAgICAgICAgb2xsYW1hSXRlbS5jcmVhdGVFbCgnY29kZScsIHsgdGV4dDogJ2h0dHA6Ly9sb2NhbGhvc3Q6MTE0MzQnIH0pO1xuICAgICAgICBvbGxhbWFJdGVtLmNyZWF0ZUVsKCdicicpO1xuICAgICAgICBvbGxhbWFJdGVtLmNyZWF0ZVNwYW4oe1xuICAgICAgICAgICAgdGV4dDogJyhXaWxsIGJlIGNvbnZlcnRlZCB0byAvdjEvY2hhdC9jb21wbGV0aW9ucyBmb3JtYXQpJyxcbiAgICAgICAgICAgIGNsczogJ3NldHRpbmctaXRlbS1kZXNjcmlwdGlvbidcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTE0gU3R1ZGlvIGV4YW1wbGVcbiAgICAgICAgY29uc3QgbG1TdHVkaW9JdGVtID0gbGlzdC5jcmVhdGVFbCgnbGknKTtcbiAgICAgICAgbG1TdHVkaW9JdGVtLmNyZWF0ZVNwYW4oeyB0ZXh0OiAnTE0gU3R1ZGlvOiAnIH0pO1xuICAgICAgICBsbVN0dWRpb0l0ZW0uY3JlYXRlRWwoJ2NvZGUnLCB7IHRleHQ6ICdodHRwOi8vbG9jYWxob3N0OjEyMzQvdjEvY2hhdC9jb21wbGV0aW9ucycgfSk7XG5cbiAgICAgICAgLy8gTG9jYWxBSSBleGFtcGxlXG4gICAgICAgIGNvbnN0IGxvY2FsQUlJdGVtID0gbGlzdC5jcmVhdGVFbCgnbGknKTtcbiAgICAgICAgbG9jYWxBSUl0ZW0uY3JlYXRlU3Bhbih7IHRleHQ6ICdMb2NhbEFJOiAnIH0pO1xuICAgICAgICBsb2NhbEFJSXRlbS5jcmVhdGVFbCgnY29kZScsIHsgdGV4dDogJ2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC92MS9jaGF0L2NvbXBsZXRpb25zJyB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdMb2NhbCBMTE0gRW5kcG9pbnQnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0VudGVyIHRoZSBiYXNlIFVSTCBmb3IgeW91ciBsb2NhbCBzZXJ2aWNlJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignaHR0cDovL2xvY2FsaG9zdDoxMTQzNCcpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmxvY2FsRW5kcG9pbnQpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5sb2NhbEVuZHBvaW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdNb2RlbCBOYW1lJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdOYW1lIG9mIHRoZSBtb2RlbCB0byB1c2Ugd2l0aCB5b3VyIGxvY2FsIHNlcnZpY2UnKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdsbGFtYTInKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5sb2NhbE1vZGVsKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MubG9jYWxNb2RlbCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgdGhpcy5jcmVhdGVUZXN0QnV0dG9uKGNvbnRhaW5lckVsKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRpc3BsYXlDbG91ZFNldHRpbmdzKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGNyZWF0ZUZyYWdtZW50KGRlc2NFbCA9PiB7XG4gICAgICAgICAgICBkZXNjRWwuYXBwZW5kVGV4dCgnQ29tcGxldGUgY2hhdCBjb21wbGV0aW9ucyBBUEkgZW5kcG9pbnQgVVJMLicpO1xuICAgICAgICAgICAgZGVzY0VsLmNyZWF0ZUVsKCdicicpO1xuICAgICAgICAgICAgZGVzY0VsLmFwcGVuZFRleHQoJ0ZvciBleGFtcGxlLCBPcGVuQUlcXCdzIGVuZHBvaW50OicpO1xuICAgICAgICAgICAgZGVzY0VsLmNyZWF0ZUVsKCdicicpO1xuICAgICAgICAgICAgZGVzY0VsLmNyZWF0ZUVsKCdjb2RlJywge1xuICAgICAgICAgICAgICAgIHRleHQ6ICdodHRwczovL2FwaS5vcGVuYWkuY29tL3YxL2NoYXQvY29tcGxldGlvbnMnLFxuICAgICAgICAgICAgICAgIGNsczogJ2VuZHBvaW50LWRlc2NyaXB0aW9uJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0FQSSBFbmRwb2ludCcpXG4gICAgICAgICAgICAuc2V0RGVzYyhkZXNjcmlwdGlvbilcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MS9jaGF0L2NvbXBsZXRpb25zJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuY2xvdWRFbmRwb2ludClcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmNsb3VkRW5kcG9pbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0FQSSBLZXknKVxuICAgICAgICAgICAgLnNldERlc2MoJ0Nsb3VkIHNlcnZpY2UgQVBJIGtleScpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ3NrLS4uLicpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmNsb3VkQXBpS2V5KVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY2xvdWRBcGlLZXkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ01vZGVsIE5hbWUnKVxuICAgICAgICAgICAgLnNldERlc2MoJ05hbWUgb2YgbW9kZWwgdG8gdXNlJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignZ3B0LTMuNS10dXJibycpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmNsb3VkTW9kZWwpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jbG91ZE1vZGVsID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICB0aGlzLmNyZWF0ZVRlc3RCdXR0b24oY29udGFpbmVyRWwpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZGlzcGxheUdlbmVyYWxTZXR0aW5ncyhjb250YWluZXJFbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnTWF4aW11bSBOZXcgVGFncycpXG4gICAgICAgICAgICAuc2V0RGVzYygnTWF4aW11bSBudW1iZXIgb2YgbmV3IHRhZ3MgdG8gZ2VuZXJhdGUgKDMtMTApJylcbiAgICAgICAgICAgIC5hZGRTbGlkZXIoc2xpZGVyID0+IHNsaWRlclxuICAgICAgICAgICAgICAgIC5zZXRMaW1pdHMoMywgMTAsIDEpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm1heE5ld1RhZ3MpXG4gICAgICAgICAgICAgICAgLnNldER5bmFtaWNUb29sdGlwKClcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm1heE5ld1RhZ3MgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ01heGltdW0gTWF0Y2hlZCBUYWdzJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdNYXhpbXVtIG51bWJlciBvZiB0YWdzIHRvIG1hdGNoIGZyb20gZXhpc3Rpbmcgb25lcyAoMS0zKScpXG4gICAgICAgICAgICAuYWRkU2xpZGVyKHNsaWRlciA9PiBzbGlkZXJcbiAgICAgICAgICAgICAgICAuc2V0TGltaXRzKDEsIDMsIDEpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm1heE1hdGNoZWRUYWdzKVxuICAgICAgICAgICAgICAgIC5zZXREeW5hbWljVG9vbHRpcCgpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5tYXhNYXRjaGVkVGFncyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgLy8gQWRkIHN1cHBvcnQgc2VjdGlvblxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7dGV4dDogJ1x1NjUyRlx1NjMwMVx1NUYwMFx1NTNEMVx1ODAwNSd9KTtcbiAgICAgICAgY29uc3Qgc3VwcG9ydEVsID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KCdzdXBwb3J0LWNvbnRhaW5lcicpO1xuICAgICAgICBzdXBwb3J0RWwuY3JlYXRlU3Bhbih7dGV4dDogJ1x1NTk4Mlx1Njc5Q1x1NEY2MFx1ODlDOVx1NUY5N1x1OEZEOVx1NEUyQVx1NjNEMlx1NEVGNlx1NUJGOVx1NEY2MFx1NjcwOVx1NUUyRVx1NTJBOVx1RkYwQ1x1NTNFRlx1NEVFNVx1ODAwM1x1ODY1MVx1N0VEOVx1NjIxMVx1NEU3MFx1Njc2Rlx1NTQ5Nlx1NTU2MSBcdTI2MTVcdUZFMEYnfSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBidXR0b24gPSBuZXcgQnV0dG9uQ29tcG9uZW50KHN1cHBvcnRFbClcbiAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdCdXkgTWUgYSBDb2ZmZWUnKVxuICAgICAgICAgICAgLnNldENsYXNzKCdzdXBwb3J0LWJ1dHRvbicpXG4gICAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgd2luZG93Lm9wZW4oJ2h0dHBzOi8vYnV5bWVhY29mZmVlLmNvbS9uaWVodTIwMTVvJywgJ19ibGFuaycpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgfVxufSIsICJleHBvcnQgaW50ZXJmYWNlIExMTVJlc3BvbnNlIHtcbiAgICBzdWdnZXN0ZWRUYWdzOiBzdHJpbmdbXTtcbiAgICBtYXRjaGVkRXhpc3RpbmdUYWdzOiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMTE1TZXJ2aWNlQ29uZmlnIHtcbiAgICBlbmRwb2ludDogc3RyaW5nO1xuICAgIGFwaUtleT86IHN0cmluZztcbiAgICBtb2RlbE5hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGVudW0gQ29ubmVjdGlvblRlc3RSZXN1bHQge1xuICAgIFN1Y2Nlc3MgPSBcInN1Y2Nlc3NcIixcbiAgICBGYWlsZWQgPSBcImZhaWxlZFwiXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29ubmVjdGlvblRlc3RFcnJvciB7XG4gICAgdHlwZTogXCJ0aW1lb3V0XCIgfCBcImF1dGhcIiB8IFwibmV0d29ya1wiIHwgXCJ1bmtub3duXCI7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExMTVNlcnZpY2Uge1xuICAgIGFuYWx5emVUYWdzKGNvbnRlbnQ6IHN0cmluZywgZXhpc3RpbmdUYWdzOiBzdHJpbmdbXSk6IFByb21pc2U8TExNUmVzcG9uc2U+O1xuICAgIHRlc3RDb25uZWN0aW9uKCk6IFByb21pc2U8eyByZXN1bHQ6IENvbm5lY3Rpb25UZXN0UmVzdWx0OyBlcnJvcj86IENvbm5lY3Rpb25UZXN0RXJyb3IgfT47XG59XG4iLCAiaW1wb3J0IHsgTExNU2VydmljZUNvbmZpZywgTExNUmVzcG9uc2UsIENvbm5lY3Rpb25UZXN0UmVzdWx0LCBDb25uZWN0aW9uVGVzdEVycm9yIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlTExNU2VydmljZSB7XG4gICAgcHJvdGVjdGVkIGVuZHBvaW50OiBzdHJpbmc7XG4gICAgcHJvdGVjdGVkIG1vZGVsTmFtZTogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IoY29uZmlnOiBMTE1TZXJ2aWNlQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuZW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnQudHJpbSgpO1xuICAgICAgICB0aGlzLm1vZGVsTmFtZSA9IGNvbmZpZy5tb2RlbE5hbWUudHJpbSgpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCB2YWxpZGF0ZUNvbmZpZygpOiBzdHJpbmcgfCBudWxsIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuZHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJBUEkgZW5kcG9pbnQgaXMgbm90IGNvbmZpZ3VyZWRcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubW9kZWxOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJNb2RlbCBuYW1lIGlzIG5vdCBjb25maWd1cmVkXCI7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgVVJMKHRoaXMuZW5kcG9pbnQpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgQVBJIGVuZHBvaW50IFVSTCBmb3JtYXRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCB2YWxpZGF0ZVRhZyh0YWc6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBNdXN0IHN0YXJ0IHdpdGggIyBhbmQgY29udGFpbiBvbmx5IGxldHRlcnMsIG51bWJlcnMsIGFuZCBoeXBoZW5zXG4gICAgICAgIGNvbnN0IHRhZ1JlZ2V4ID0gL14jW2EtekEtWjAtOS1dKyQvO1xuICAgICAgICByZXR1cm4gdGFnUmVnZXgudGVzdCh0YWcpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCB2YWxpZGF0ZVRhZ3ModGFnczogc3RyaW5nW10pOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZFRhZ3M6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGVUYWcodGFnKSkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGBJbnZhbGlkIHRhZyBmb3JtYXQ6ICR7dGFnfWApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsaWRhdGVkVGFncy5wdXNoKHRhZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGFnIHZhbGlkYXRpb24gZXJyb3JzOlxcbiR7ZXJyb3JzLmpvaW4oJ1xcbicpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbGlkYXRlZFRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIHRhZ3MgZm91bmQgaW4gcmVzcG9uc2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRUYWdzO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBleHRyYWN0SlNPTkZyb21SZXNwb25zZShyZXNwb25zZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1JhdyByZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBUcnkgdG8gZmluZCBKU09OIGNvbnRlbnQgd2l0aGluIG1hcmtkb3duIGNvZGUgYmxvY2tzXG4gICAgICAgIGNvbnN0IG1hcmtkb3duSnNvblJlZ2V4ID0gL2BgYCg/Ompzb24pP1xccyooXFx7W1xcc1xcU10qP1xcfSlcXHMqYGBgLztcbiAgICAgICAgY29uc3QgbWFya2Rvd25NYXRjaCA9IHJlc3BvbnNlLm1hdGNoKG1hcmtkb3duSnNvblJlZ2V4KTtcbiAgICAgICAgaWYgKG1hcmtkb3duTWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBKU09OIGluIG1hcmtkb3duIGJsb2NrOicsIG1hcmtkb3duTWF0Y2hbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIG1hcmtkb3duTWF0Y2hbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcnkgdG8gZmluZCBzdGFuZGFsb25lIEpTT04gb2JqZWN0XG4gICAgICAgIGNvbnN0IGpzb25SZWdleCA9IC9cXHtbXFxzXFxTXSpcXH0vO1xuICAgICAgICBjb25zdCBqc29uTWF0Y2ggPSByZXNwb25zZS5tYXRjaChqc29uUmVnZXgpO1xuICAgICAgICBpZiAoanNvbk1hdGNoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgc3RhbmRhbG9uZSBKU09OOicsIGpzb25NYXRjaFswXSk7XG4gICAgICAgICAgICByZXR1cm4ganNvbk1hdGNoWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBKU09OIGZvdW5kIGluIHJlc3BvbnNlJyk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGJ1aWxkUHJvbXB0KGNvbnRlbnQ6IHN0cmluZywgZXhpc3RpbmdUYWdzOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgQW5hbHl6ZSB0aGUgZm9sbG93aW5nIGNvbnRlbnQgYW5kOlxuMS4gTWF0Y2ggMS0zIG1vc3QgcmVsZXZhbnQgdGFncyBmcm9tIGV4aXN0aW5nIHRhZ3NcbjIuIEdlbmVyYXRlIDMtMTAgbmV3IHJlbGV2YW50IHRhZ3NcblxuUmVxdWlyZW1lbnRzIGZvciB0YWdzOlxuLSBNdXN0IHN0YXJ0IHdpdGggIyBzeW1ib2xcbi0gQ2FuIG9ubHkgY29udGFpbiBsZXR0ZXJzLCBudW1iZXJzLCBhbmQgaHlwaGVuc1xuLSBObyBzcGFjZXMgYWxsb3dlZFxuLSBFeGFtcGxlIGZvcm1hdDogI3RlY2hub2xvZ3ksICNhcnRpZmljaWFsLWludGVsbGlnZW5jZSwgI2NvZGluZ1xuXG5FeGlzdGluZyB0YWdzOlxuJHtleGlzdGluZ1RhZ3Muam9pbignLCAnKX1cblxuQ29udGVudDpcbiR7Y29udGVudH1cblxuUmV0dXJuIG9ubHkgYSBKU09OIG9iamVjdCBpbiB0aGlzIGV4YWN0IGZvcm1hdDpcbntcbiAgICBcIm1hdGNoZWRUYWdzXCI6IFtcIiN0YWcxXCIsIFwiI3RhZzJcIl0sXG4gICAgXCJuZXdUYWdzXCI6IFtcIiN0YWcxXCIsIFwiI3RhZzJcIiwgXCIjdGFnM1wiXVxufWA7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlUmVzcG9uc2UocmVzcG9uc2U6IHN0cmluZyk6IExMTVJlc3BvbnNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIHBhcnNlIHJlc3BvbnNlLi4uJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgSlNPTiBmcm9tIHJlc3BvbnNlXG4gICAgICAgICAgICBjb25zdCBqc29uQ29udGVudCA9IHRoaXMuZXh0cmFjdEpTT05Gcm9tUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0V4dHJhY3RlZCBKU09OIGNvbnRlbnQ6JywganNvbkNvbnRlbnQpO1xuXG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgSlNPTlxuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShqc29uQ29udGVudCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUGFyc2VkIEpTT046JywgcGFyc2VkKTtcblxuICAgICAgICAgICAgaWYgKCFwYXJzZWQubWF0Y2hlZFRhZ3MgfHwgIUFycmF5LmlzQXJyYXkocGFyc2VkLm1hdGNoZWRUYWdzKSB8fCBcbiAgICAgICAgICAgICAgICAhcGFyc2VkLm5ld1RhZ3MgfHwgIUFycmF5LmlzQXJyYXkocGFyc2VkLm5ld1RhZ3MpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCByZXNwb25zZSBzdHJ1Y3R1cmU6JywgcGFyc2VkKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIG1pc3NpbmcgcmVxdWlyZWQgZmllbGRzJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIGFsbCB0YWdzXG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0ZWRNYXRjaGVkVGFncyA9IHRoaXMudmFsaWRhdGVUYWdzKHBhcnNlZC5tYXRjaGVkVGFncyk7XG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0ZWROZXdUYWdzID0gdGhpcy52YWxpZGF0ZVRhZ3MocGFyc2VkLm5ld1RhZ3MpO1xuXG4gICAgICAgICAgICAvLyBFbnN1cmUgbm8gZHVwbGljYXRlc1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlVGFncyA9IG5ldyBTZXQoWy4uLnZhbGlkYXRlZE1hdGNoZWRUYWdzLCAuLi52YWxpZGF0ZWROZXdUYWdzXSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZEV4aXN0aW5nVGFnczogdmFsaWRhdGVkTWF0Y2hlZFRhZ3MsXG4gICAgICAgICAgICAgICAgc3VnZ2VzdGVkVGFnczogQXJyYXkuZnJvbShuZXcgU2V0KHZhbGlkYXRlZE5ld1RhZ3MpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgcmVzcG9uc2U6JywgZXJyb3IpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignUmF3IHJlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGhhbmRsZUVycm9yKGVycm9yOiB1bmtub3duLCBvcGVyYXRpb246IHN0cmluZyk6IG5ldmVyIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gJHtvcGVyYXRpb259OmAsIGVycm9yKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9wZXJhdGlvbiB0aW1lZCBvdXQ6ICR7b3BlcmF0aW9ufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke29wZXJhdGlvbn0gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgYWJzdHJhY3QgYW5hbHl6ZVRhZ3MoY29udGVudDogc3RyaW5nLCBleGlzdGluZ1RhZ3M6IHN0cmluZ1tdKTogUHJvbWlzZTxMTE1SZXNwb25zZT47XG4gICAgYWJzdHJhY3QgdGVzdENvbm5lY3Rpb24oKTogUHJvbWlzZTx7IHJlc3VsdDogQ29ubmVjdGlvblRlc3RSZXN1bHQ7IGVycm9yPzogQ29ubmVjdGlvblRlc3RFcnJvciB9Pjtcbn0iLCAiaW1wb3J0IHsgTExNUmVzcG9uc2UsIExMTVNlcnZpY2VDb25maWcsIENvbm5lY3Rpb25UZXN0UmVzdWx0LCBDb25uZWN0aW9uVGVzdEVycm9yIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBCYXNlTExNU2VydmljZSB9IGZyb20gJy4vYmFzZVNlcnZpY2UnO1xuXG5leHBvcnQgY2xhc3MgTG9jYWxMTE1TZXJ2aWNlIGV4dGVuZHMgQmFzZUxMTVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZzogTExNU2VydmljZUNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICAvLyBFbnN1cmUgZW5kcG9pbnQgZW5kcyB3aXRoIHN0YW5kYXJkIGNoYXQgY29tcGxldGlvbnMgcGF0aFxuICAgICAgICB0aGlzLmVuZHBvaW50ID0gdGhpcy5ub3JtYWxpemVFbmRwb2ludChjb25maWcuZW5kcG9pbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgbm9ybWFsaXplRW5kcG9pbnQoZW5kcG9pbnQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGVuZHBvaW50ID0gZW5kcG9pbnQudHJpbSgpO1xuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgc2xhc2ggaWYgcHJlc2VudFxuICAgICAgICBlbmRwb2ludCA9IGVuZHBvaW50LnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgICAgIC8vIENvbnZlcnQgT2xsYW1hIGZvcm1hdCB0byBzdGFuZGFyZCBmb3JtYXQgaWYgbmVlZGVkXG4gICAgICAgIGlmIChlbmRwb2ludC5lbmRzV2l0aCgnL2FwaS9nZW5lcmF0ZScpKSB7XG4gICAgICAgICAgICBlbmRwb2ludCA9IGVuZHBvaW50LnJlcGxhY2UoJy9hcGkvZ2VuZXJhdGUnLCAnL3YxL2NoYXQvY29tcGxldGlvbnMnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgc3RhbmRhcmQgcGF0aCBpZiBub3QgcHJlc2VudFxuICAgICAgICBpZiAoIWVuZHBvaW50LmVuZHNXaXRoKCcvdjEvY2hhdC9jb21wbGV0aW9ucycpKSB7XG4gICAgICAgICAgICBlbmRwb2ludCA9IGAke2VuZHBvaW50fS92MS9jaGF0L2NvbXBsZXRpb25zYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5kcG9pbnQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZUxvY2FsQ29uZmlnKCk6IHN0cmluZyB8IG51bGwge1xuICAgICAgICBjb25zdCBiYXNlRXJyb3IgPSB0aGlzLnZhbGlkYXRlQ29uZmlnKCk7XG4gICAgICAgIGlmIChiYXNlRXJyb3IpIHJldHVybiBiYXNlRXJyb3I7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodGhpcy5lbmRwb2ludCk7XG4gICAgICAgICAgICBpZiAoIXVybC5wYXRobmFtZS5lbmRzV2l0aCgnL3YxL2NoYXQvY29tcGxldGlvbnMnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgZW5kcG9pbnQgZm9ybWF0LiBTaG91bGQgZW5kIHdpdGggL3YxL2NoYXQvY29tcGxldGlvbnNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gXCJJbnZhbGlkIGVuZHBvaW50IFVSTCBmb3JtYXRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGFzeW5jIHRlc3RDb25uZWN0aW9uKCk6IFByb21pc2U8eyByZXN1bHQ6IENvbm5lY3Rpb25UZXN0UmVzdWx0OyBlcnJvcj86IENvbm5lY3Rpb25UZXN0RXJyb3IgfT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVmFsaWRhdGUgY29uZmlndXJhdGlvbiBmaXJzdFxuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvbkVycm9yID0gdGhpcy52YWxpZGF0ZUxvY2FsQ29uZmlnKCk7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBDb25uZWN0aW9uVGVzdFJlc3VsdC5GYWlsZWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm5ldHdvcmtcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZhbGlkYXRpb25FcnJvclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCAxMDAwMCk7IC8vIDEwIHNlY29uZCB0aW1lb3V0XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUZXN0aW5nIGxvY2FsIExMTSBjb25uZWN0aW9uIHdpdGggZW5kcG9pbnQ6JywgdGhpcy5lbmRwb2ludCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy5lbmRwb2ludCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWxOYW1lLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdUZXN0IGNvbm5lY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgICAgICBtYXhfdG9rZW5zOiA1XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZVRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTG9jYWwgTExNIHRlc3QgcmVzcG9uc2U6JywgcmVzcG9uc2VUZXh0KTtcblxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YS5jaG9pY2VzIHx8ICFBcnJheS5pc0FycmF5KGRhdGEuY2hvaWNlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQYXJzZSBlcnJvcjonLCBwYXJzZUVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVzcG9uc2UgZm9ybWF0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogQ29ubmVjdGlvblRlc3RSZXN1bHQuU3VjY2VzcyB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTG9jYWwgTExNIGNvbm5lY3Rpb24gdGVzdCBlcnJvcjonLCBlcnJvcik7XG5cbiAgICAgICAgICAgIGxldCB0ZXN0RXJyb3I6IENvbm5lY3Rpb25UZXN0RXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1bmtub3duXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJVbmtub3duIGVycm9yXCJcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXN0RXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRpbWVvdXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQ29ubmVjdGlvbiB0aW1lb3V0LCBwbGVhc2UgY2hlY2sgaWYgdGhlIGxvY2FsIExMTSBzZXJ2aWNlIGlzIHJ1bm5pbmdcIlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnRmFpbGVkIHRvIGZldGNoJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVzdEVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJuZXR3b3JrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIk5ldHdvcmsgZXJyb3IsIHBsZWFzZSBjaGVjayBpZiB0aGUgbG9jYWwgc2VydmljZSBpcyBhY2Nlc3NpYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0hUVFAgZXJyb3InKSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXN0RXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm5ldHdvcmtcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBTZXJ2aWNlIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnSW52YWxpZCByZXNwb25zZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RFcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidW5rbm93blwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdCBmcm9tIGxvY2FsIHNlcnZpY2VcIlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IENvbm5lY3Rpb25UZXN0UmVzdWx0LkZhaWxlZCxcbiAgICAgICAgICAgICAgICBlcnJvcjogdGVzdEVycm9yXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgYW5hbHl6ZVRhZ3MoY29udGVudDogc3RyaW5nLCBleGlzdGluZ1RhZ3M6IHN0cmluZ1tdKTogUHJvbWlzZTxMTE1SZXNwb25zZT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVmFsaWRhdGUgY29uZmlndXJhdGlvbiBmaXJzdFxuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvbkVycm9yID0gdGhpcy52YWxpZGF0ZUxvY2FsQ29uZmlnKCk7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHZhbGlkYXRpb25FcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgMzAwMDApOyAvLyAzMCBzZWNvbmQgdGltZW91dFxuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuZW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiAnc3lzdGVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnWW91IGFyZSBhIHByb2Zlc3Npb25hbCBkb2N1bWVudCB0YWcgYW5hbHlzaXMgYXNzaXN0YW50LiBZb3UgbmVlZCB0byBhbmFseXplIGNvbnRlbnQgYW5kIHN1Z2dlc3QgcmVsZXZhbnQgdGFncy4nXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLmJ1aWxkUHJvbXB0KGNvbnRlbnQsIGV4aXN0aW5nVGFncylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGVyYXR1cmU6IDAuMyAgLy8gTG93ZXIgdGVtcGVyYXR1cmUgZm9yIG1vcmUgZm9jdXNlZCByZXNwb25zZXNcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMb2NhbCBMTE0gcmVzcG9uc2U6JywgcmVzcG9uc2VUZXh0KTtcblxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dFRvQW5hbHl6ZSA9IGRhdGEuY2hvaWNlcz8uWzBdPy5tZXNzYWdlPy5jb250ZW50O1xuICAgICAgICAgICAgICAgIGlmICghdGV4dFRvQW5hbHl6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVzcG9uc2UgY29udGVudCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJlc3BvbnNlKHRleHRUb0FuYWx5emUpO1xuICAgICAgICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BhcnNlIGVycm9yOicsIHBhcnNlRXJyb3IsICdSZXNwb25zZTonLCByZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZSBmb3JtYXQgZnJvbSBsb2NhbCBzZXJ2aWNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVFcnJvcihlcnJvciwgJ1RhZyBhbmFseXNpcycpO1xuICAgICAgICB9XG4gICAgfVxufSIsICJpbXBvcnQgeyBMTE1SZXNwb25zZSwgTExNU2VydmljZUNvbmZpZywgQ29ubmVjdGlvblRlc3RSZXN1bHQsIENvbm5lY3Rpb25UZXN0RXJyb3IgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IEJhc2VMTE1TZXJ2aWNlIH0gZnJvbSAnLi9iYXNlU2VydmljZSc7XG5cbmV4cG9ydCBjbGFzcyBDbG91ZExMTVNlcnZpY2UgZXh0ZW5kcyBCYXNlTExNU2VydmljZSB7XG4gICAgcHJpdmF0ZSBhcGlLZXk6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZzogTExNU2VydmljZUNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICB0aGlzLmFwaUtleSA9IGNvbmZpZy5hcGlLZXk/LnRyaW0oKSB8fCAnJztcbiAgICB9XG5cbiAgICBwcml2YXRlIHZhbGlkYXRlQ2xvdWRDb25maWcoKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGJhc2VFcnJvciA9IHRoaXMudmFsaWRhdGVDb25maWcoKTtcbiAgICAgICAgaWYgKGJhc2VFcnJvcikgcmV0dXJuIGJhc2VFcnJvcjtcblxuICAgICAgICBpZiAoIXRoaXMuYXBpS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJBUEkga2V5IGlzIG5vdCBjb25maWd1cmVkXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuZW5kcG9pbnQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnL2NoYXQvY29tcGxldGlvbnMnKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiQ2xvdWQgQVBJIGVuZHBvaW50IHNob3VsZCBpbmNsdWRlICcvY2hhdC9jb21wbGV0aW9ucydcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGFzeW5jIHRlc3RDb25uZWN0aW9uKCk6IFByb21pc2U8eyByZXN1bHQ6IENvbm5lY3Rpb25UZXN0UmVzdWx0OyBlcnJvcj86IENvbm5lY3Rpb25UZXN0RXJyb3IgfT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvbkVycm9yID0gdGhpcy52YWxpZGF0ZUNsb3VkQ29uZmlnKCk7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBDb25uZWN0aW9uVGVzdFJlc3VsdC5GYWlsZWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm5ldHdvcmtcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZhbGlkYXRpb25FcnJvclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCAxMDAwMCk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUZXN0aW5nIGNvbm5lY3Rpb24gd2l0aCBlbmRwb2ludDonLCB0aGlzLmVuZHBvaW50KTtcblxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLmVuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmFwaUtleX1gXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiAnc3lzdGVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnQ29ubmVjdGlvbiB0ZXN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBtYXhfdG9rZW5zOiA1XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZVRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQ2xvdWQgQVBJIHRlc3QgcmVzcG9uc2U6JywgcmVzcG9uc2VUZXh0KTtcblxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZDogSW52YWxpZCBBUEkga2V5Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FQSSBlbmRwb2ludCBub3QgZm91bmQ6IFBsZWFzZSB2ZXJpZnkgdGhlIFVSTCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ySnNvbiA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ySnNvbi5lcnJvcj8ubWVzc2FnZSB8fCBlcnJvckpzb24ubWVzc2FnZSB8fCBgSFRUUCBlcnJvciAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZVRleHR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBWZXJpZnkgcmVzcG9uc2UgZm9ybWF0XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgaWYgKCFkYXRhLmNob2ljZXMgfHwgIUFycmF5LmlzQXJyYXkoZGF0YS5jaG9pY2VzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBBUEkgcmVzcG9uc2UgZm9ybWF0OiBtaXNzaW5nIGNob2ljZXMgYXJyYXknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBDb25uZWN0aW9uVGVzdFJlc3VsdC5TdWNjZXNzIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsZXQgdGVzdEVycm9yOiBDb25uZWN0aW9uVGVzdEVycm9yID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5rbm93blwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiVW5rbm93biBlcnJvciBvY2N1cnJlZCBkdXJpbmcgY29ubmVjdGlvbiB0ZXN0XCJcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXN0RXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRpbWVvdXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQ29ubmVjdGlvbiB0aW1lb3V0OiBQbGVhc2UgY2hlY2sgeW91ciBuZXR3b3JrIHN0YXR1c1wiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdGYWlsZWQgdG8gZmV0Y2gnKSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXN0RXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm5ldHdvcmtcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTmV0d29yayBlcnJvcjogVW5hYmxlIHRvIHJlYWNoIHRoZSBBUEkgZW5kcG9pbnRcIlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnQXV0aGVudGljYXRpb24gZmFpbGVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVzdEVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhdXRoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkF1dGhlbnRpY2F0aW9uIGZhaWxlZDogUGxlYXNlIHZlcmlmeSB5b3VyIEFQSSBrZXlcIlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnQVBJIGVuZHBvaW50IG5vdCBmb3VuZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RFcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibmV0d29ya1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBUEkgZW5kcG9pbnQgbm90IGZvdW5kOiBQbGVhc2UgdmVyaWZ5IHRoZSBVUkxcIlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RFcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidW5rbm93blwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2xvdWQgQVBJIHRlc3QgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IENvbm5lY3Rpb25UZXN0UmVzdWx0LkZhaWxlZCxcbiAgICAgICAgICAgICAgICBlcnJvcjogdGVzdEVycm9yXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgYW5hbHl6ZVRhZ3MoY29udGVudDogc3RyaW5nLCBleGlzdGluZ1RhZ3M6IHN0cmluZ1tdKTogUHJvbWlzZTxMTE1SZXNwb25zZT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvbkVycm9yID0gdGhpcy52YWxpZGF0ZUNsb3VkQ29uZmlnKCk7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHZhbGlkYXRpb25FcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgMzAwMDApO1xuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuZW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3RoaXMuYXBpS2V5fWBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWxOYW1lLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICdzeXN0ZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdZb3UgYXJlIGEgcHJvZmVzc2lvbmFsIGRvY3VtZW50IHRhZyBhbmFseXNpcyBhc3Npc3RhbnQuIFlvdSBuZWVkIHRvIGFuYWx5emUgZG9jdW1lbnQgY29udGVudCwgbWF0Y2ggcmVsZXZhbnQgdGFncyBmcm9tIGV4aXN0aW5nIG9uZXMsIGFuZCBnZW5lcmF0ZSBuZXcgcmVsZXZhbnQgdGFncy4nXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLmJ1aWxkUHJvbXB0KGNvbnRlbnQsIGV4aXN0aW5nVGFncylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcblxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0Nsb3VkIEFQSSByZXNwb25zZTonLCByZXNwb25zZVRleHQpO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JKc29uID0gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JKc29uLmVycm9yPy5tZXNzYWdlIHx8IGVycm9ySnNvbi5tZXNzYWdlIHx8IGBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICBpZiAoIWRhdGEuY2hvaWNlcyB8fCAhZGF0YS5jaG9pY2VzWzBdPy5tZXNzYWdlPy5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEFQSSByZXNwb25zZSBmb3JtYXQ6IG1pc3NpbmcgbWVzc2FnZSBjb250ZW50Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmVzcG9uc2UoZGF0YS5jaG9pY2VzWzBdLm1lc3NhZ2UuY29udGVudCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVFcnJvcihlcnJvciwgJ1RhZyBhbmFseXNpcycpO1xuICAgICAgICB9XG4gICAgfVxufSIsICJpbXBvcnQgeyBURmlsZSwgRnJvbnRNYXR0ZXJDYWNoZSwgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRhZ09wZXJhdGlvblJlc3VsdCB7XG4gICAgc3VjY2VzczogYm9vbGVhbjtcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgdGFncz86IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgY2xhc3MgVGFnVXRpbHMge1xuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRhZyBmb3JtYXRcbiAgICAgKiBNdXN0IHN0YXJ0IHdpdGggIyBhbmQgY29udGFpbiBvbmx5IGxldHRlcnMsIG51bWJlcnMsIGFuZCBoeXBoZW5zXG4gICAgICovXG4gICAgc3RhdGljIHZhbGlkYXRlVGFnKHRhZzogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHRhZ1JlZ2V4ID0gL14jW2EtekEtWjAtOS1dKyQvO1xuICAgICAgICByZXR1cm4gdGFnUmVnZXgudGVzdCh0YWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIG11bHRpcGxlIHRhZ3MgYW5kIHJldHVybiBvbmx5IHZhbGlkIG9uZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgdmFsaWRhdGVUYWdzKHRhZ3M6IHN0cmluZ1tdKTogeyB2YWxpZDogc3RyaW5nW10sIGludmFsaWQ6IHN0cmluZ1tdIH0ge1xuICAgICAgICBjb25zdCB2YWxpZDogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgY29uc3QgaW52YWxpZDogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy52YWxpZGF0ZVRhZyh0YWcpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWQucHVzaCh0YWcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnZhbGlkLnB1c2godGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHZhbGlkLCBpbnZhbGlkIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCBleGlzdGluZyB0YWdzIGZyb20gbm90ZSdzIGZyb250bWF0dGVyXG4gICAgICovXG4gICAgc3RhdGljIGdldEV4aXN0aW5nVGFncyhmcm9udG1hdHRlcjogRnJvbnRNYXR0ZXJDYWNoZSB8IG51bGwpOiBzdHJpbmdbXSB7XG4gICAgICAgIGlmICghZnJvbnRtYXR0ZXIgfHwgIWZyb250bWF0dGVyLnRhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB0YWdzIG1pZ2h0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGEgc2luZ2xlIHN0cmluZ1xuICAgICAgICBsZXQgdGFnczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbnRtYXR0ZXIudGFncykpIHtcbiAgICAgICAgICAgIHRhZ3MgPSBmcm9udG1hdHRlci50YWdzO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmcm9udG1hdHRlci50YWdzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGFncyA9IFtmcm9udG1hdHRlci50YWdzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIGFuZCBmaWx0ZXIgdGFnc1xuICAgICAgICBjb25zdCB7IHZhbGlkLCBpbnZhbGlkIH0gPSB0aGlzLnZhbGlkYXRlVGFncyh0YWdzKTtcbiAgICAgICAgaWYgKGludmFsaWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGb3VuZCBpbnZhbGlkIHRhZ3MgaW4gZnJvbnRtYXR0ZXI6JywgaW52YWxpZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2UgbmV3IGFuZCBleGlzdGluZyB0YWdzIHdpdGggZGVkdXBsaWNhdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBtZXJnZVRhZ3MoZXhpc3RpbmdUYWdzOiBzdHJpbmdbXSwgbmV3VGFnczogc3RyaW5nW10pOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IHsgdmFsaWQ6IHZhbGlkRXhpc3RpbmcgfSA9IHRoaXMudmFsaWRhdGVUYWdzKGV4aXN0aW5nVGFncyk7XG4gICAgICAgIGNvbnN0IHsgdmFsaWQ6IHZhbGlkTmV3IH0gPSB0aGlzLnZhbGlkYXRlVGFncyhuZXdUYWdzKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGFsbFRhZ3MgPSBbLi4udmFsaWRFeGlzdGluZywgLi4udmFsaWROZXddO1xuICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQoYWxsVGFncyldLnNvcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgdGFnIChlbnN1cmUgaXQgc3RhcnRzIHdpdGggIylcbiAgICAgKi9cbiAgICBzdGF0aWMgZm9ybWF0VGFnKHRhZzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgdGFnID0gdGFnLnRyaW0oKTtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkVGFnID0gdGFnLnN0YXJ0c1dpdGgoJyMnKSA/IHRhZyA6IGAjJHt0YWd9YDtcbiAgICAgICAgXG4gICAgICAgIGlmICghdGhpcy52YWxpZGF0ZVRhZyhmb3JtYXR0ZWRUYWcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdGFnIGZvcm1hdDogJHt0YWd9IChjYW4gb25seSBjb250YWluIGxldHRlcnMsIG51bWJlcnMsIGFuZCBoeXBoZW5zKWApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgdGFncyB3aGlsZSBrZWVwaW5nIHRoZSB0YWdzIGZpZWxkXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGNsZWFyVGFncyhcbiAgICAgICAgYXBwOiBhbnksXG4gICAgICAgIGZpbGU6IFRGaWxlXG4gICAgKTogUHJvbWlzZTxUYWdPcGVyYXRpb25SZXN1bHQ+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFJlYWQgbm90ZSBjb250ZW50XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgYXBwLnZhdWx0LnJlYWQoZmlsZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYSBmcm9udG1hdHRlciBzZWN0aW9uXG4gICAgICAgICAgICBpZiAoIWNvbnRlbnQuc3RhcnRzV2l0aCgnLS0tXFxuJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ05vIGZyb250bWF0dGVyIGZvdW5kIGluIHRoZSBub3RlJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGVuZE9mRnJvbnRNYXR0ZXIgPSBjb250ZW50LmluZGV4T2YoJy0tLVxcbicsIDQpO1xuICAgICAgICAgICAgaWYgKGVuZE9mRnJvbnRNYXR0ZXIgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGZyb250bWF0dGVyIGZvcm1hdCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgZnJvbnRtYXR0ZXIgc2VjdGlvblxuICAgICAgICAgICAgY29uc3QgZnJvbnRNYXR0ZXIgPSBjb250ZW50LnNsaWNlKDQsIGVuZE9mRnJvbnRNYXR0ZXIpO1xuICAgICAgICAgICAgY29uc3QgYWZ0ZXJGcm9udE1hdHRlciA9IGNvbnRlbnQuc2xpY2UoZW5kT2ZGcm9udE1hdHRlcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEdldCB0aGUgbGluZXMgYmVmb3JlIGFuZCBhZnRlciB0YWdzIGZpZWxkXG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IGZyb250TWF0dGVyLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0xpbmVzID0gW107XG4gICAgICAgICAgICBsZXQgaW5UYWdzQmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCB0YWdzRm91bmQgPSBmYWxzZTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoJ3RhZ3M6JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnc0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbmV3TGluZXMucHVzaCgndGFnczonKTtcbiAgICAgICAgICAgICAgICAgICAgaW5UYWdzQmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5UYWdzQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoJy0nKSB8fCBsaW5lLnRyaW0oKS5zdGFydHNXaXRoKCcgIC0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIFNraXAgdGFnIGVudHJpZXNcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluVGFnc0Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWluVGFnc0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0xpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBubyB0YWdzIGZpZWxkIHdhcyBmb3VuZCwgYWRkIGl0XG4gICAgICAgICAgICBpZiAoIXRhZ3NGb3VuZCkge1xuICAgICAgICAgICAgICAgIG5ld0xpbmVzLnB1c2goJ3RhZ3M6Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCBuZXcgY29udGVudFxuICAgICAgICAgICAgY29uc3QgbmV3Q29udGVudCA9IGAtLS1cXG4ke25ld0xpbmVzLmpvaW4oJ1xcbicpfSR7YWZ0ZXJGcm9udE1hdHRlcn1gO1xuXG4gICAgICAgICAgICAvLyBTYXZlIHVwZGF0ZWQgY29udGVudCBhbmQgd2FpdCBmb3IgaXQgdG8gY29tcGxldGVcbiAgICAgICAgICAgIGF3YWl0IGFwcC52YXVsdC5tb2RpZnkoZmlsZSwgbmV3Q29udGVudCk7XG5cbiAgICAgICAgICAgIC8vIEZvcmNlIG1ldGFkYXRhIGNhY2hlIHVwZGF0ZSBhbmQgd2FpdCBmb3IgaXRcbiAgICAgICAgICAgIGF3YWl0IGFwcC5tZXRhZGF0YUNhY2hlLnRyaWdnZXIoJ2NoYW5nZWQnLCBmaWxlKTtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcblxuICAgICAgICAgICAgLy8gVHJpZ2dlciBmaWxlIHJlbG9hZFxuICAgICAgICAgICAgYXBwLndvcmtzcGFjZS50cmlnZ2VyKCdmaWxlLW9wZW4nLCBmaWxlKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdTdWNjZXNzZnVsbHkgY2xlYXJlZCBhbGwgdGFncycsXG4gICAgICAgICAgICAgICAgdGFnczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjbGVhcmluZyB0YWdzOicsIGVycm9yKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InO1xuICAgICAgICAgICAgbmV3IE5vdGljZSgnRXJyb3IgY2xlYXJpbmcgdGFncycpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRmFpbGVkIHRvIGNsZWFyIHRhZ3M6ICR7ZXJyb3JNZXNzYWdlfWBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgbm90ZSdzIGZyb250bWF0dGVyXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHVwZGF0ZU5vdGVUYWdzKFxuICAgICAgICBhcHA6IGFueSxcbiAgICAgICAgZmlsZTogVEZpbGUsXG4gICAgICAgIG5ld1RhZ3M6IHN0cmluZ1tdLFxuICAgICAgICBtYXRjaGVkVGFnczogc3RyaW5nW11cbiAgICApOiBQcm9taXNlPFRhZ09wZXJhdGlvblJlc3VsdD4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVmFsaWRhdGUgYWxsIHRhZ3MgZmlyc3RcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsaWQ6IHZhbGlkTmV3VGFncywgaW52YWxpZDogaW52YWxpZE5ld1RhZ3MgfSA9IHRoaXMudmFsaWRhdGVUYWdzKG5ld1RhZ3MpO1xuICAgICAgICAgICAgY29uc3QgeyB2YWxpZDogdmFsaWRNYXRjaGVkVGFncywgaW52YWxpZDogaW52YWxpZE1hdGNoZWRUYWdzIH0gPSB0aGlzLnZhbGlkYXRlVGFncyhtYXRjaGVkVGFncyk7XG5cbiAgICAgICAgICAgIGlmIChpbnZhbGlkTmV3VGFncy5sZW5ndGggPiAwIHx8IGludmFsaWRNYXRjaGVkVGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZFRhZ3MgPSBbLi4uaW52YWxpZE5ld1RhZ3MsIC4uLmludmFsaWRNYXRjaGVkVGFnc107XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRhZyBmb3JtYXQgZm91bmQ6ICR7aW52YWxpZFRhZ3Muam9pbignLCAnKX1cXG5UYWdzIGNhbiBvbmx5IGNvbnRhaW4gbGV0dGVycywgbnVtYmVycywgYW5kIGh5cGhlbnNgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVhZCBub3RlIGNvbnRlbnRcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBhcHAudmF1bHQucmVhZChmaWxlKTtcbiAgICAgICAgICAgIGNvbnN0IGZyb250bWF0dGVyID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5mcm9udG1hdHRlcjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gR2V0IGV4aXN0aW5nIHRhZ3NcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVGFncyA9IHRoaXMuZ2V0RXhpc3RpbmdUYWdzKGZyb250bWF0dGVyKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTWVyZ2UgYWxsIHRhZ3MgYW5kIHJlbW92ZSAjIHByZWZpeCBmb3IgWUFNTFxuICAgICAgICAgICAgY29uc3QgYWxsVGFncyA9IHRoaXMubWVyZ2VUYWdzKGV4aXN0aW5nVGFncywgWy4uLnZhbGlkTmV3VGFncywgLi4udmFsaWRNYXRjaGVkVGFnc10pXG4gICAgICAgICAgICAgICAgLm1hcCh0YWcgPT4gdGFnLnN0YXJ0c1dpdGgoJyMnKSA/IHRhZy5zdWJzdHJpbmcoMSkgOiB0YWcpOyAvLyBSZW1vdmUgIyBmb3IgWUFNTFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBCdWlsZCBuZXcgZnJvbnRtYXR0ZXJcbiAgICAgICAgICAgIGxldCBuZXdDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgICAgIGNvbnN0IHlhbWxUYWdzID0gYWxsVGFncy5tYXAodGFnID0+IGAgIC0gJHt0YWd9YCkuam9pbignXFxuJyk7XG5cbiAgICAgICAgICAgIGlmIChjb250ZW50LnN0YXJ0c1dpdGgoJy0tLVxcbicpKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIGZyb250bWF0dGVyXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kT2ZGcm9udE1hdHRlciA9IGNvbnRlbnQuaW5kZXhPZignLS0tXFxuJywgNCk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZE9mRnJvbnRNYXR0ZXIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZUZyb250TWF0dGVyID0gY29udGVudC5zbGljZSgwLCBlbmRPZkZyb250TWF0dGVyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWZ0ZXJGcm9udE1hdHRlciA9IGNvbnRlbnQuc2xpY2UoZW5kT2ZGcm9udE1hdHRlcik7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBmcm9udG1hdHRlciBhbHJlYWR5IGhhcyB0YWdzIGZpZWxkXG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmVGcm9udE1hdHRlci5pbmNsdWRlcygnXFxudGFnczonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBleGlzdGluZyB0YWdzIHNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhZ3NSZWdleCA9IC9cXG50YWdzOi4qPyg/PVxcblteXFxzXXxcXG4tLS0pL3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250ZW50ID0gYmVmb3JlRnJvbnRNYXR0ZXIucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzUmVnZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxcbnRhZ3M6XFxuJHt5YW1sVGFnc31gXG4gICAgICAgICAgICAgICAgICAgICAgICApICsgYWZ0ZXJGcm9udE1hdHRlcjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBuZXcgdGFncyBzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250ZW50ID0gYmVmb3JlRnJvbnRNYXR0ZXIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcXG50YWdzOlxcbiR7eWFtbFRhZ3N9YCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJGcm9udE1hdHRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyBmcm9udG1hdHRlclxuICAgICAgICAgICAgICAgIG5ld0NvbnRlbnQgPSBgLS0tXFxudGFnczpcXG4ke3lhbWxUYWdzfVxcbi0tLVxcblxcbiR7Y29udGVudH1gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTYXZlIHVwZGF0ZWQgY29udGVudFxuICAgICAgICAgICAgYXdhaXQgYXBwLnZhdWx0Lm1vZGlmeShmaWxlLCBuZXdDb250ZW50KTtcblxuICAgICAgICAgICAgLy8gRm9yY2UgY2FjaGUgdXBkYXRlIGFuZCB3YWl0IGZvciBpdFxuICAgICAgICAgICAgYXdhaXQgYXBwLm1ldGFkYXRhQ2FjaGUudHJpZ2dlcignY2hhbmdlZCcsIGZpbGUpO1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuXG4gICAgICAgICAgICAvLyBSZWxvYWQgdGhlIGZpbGUgdG8gdXBkYXRlIHRoZSB2aWV3XG4gICAgICAgICAgICBhcHAud29ya3NwYWNlLnRyaWdnZXIoJ2ZpbGUtb3BlbicsIGZpbGUpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFN1Y2Nlc3NmdWxseSB1cGRhdGVkIHRhZ3M6ICR7dmFsaWROZXdUYWdzLmxlbmd0aH0gbmV3IHRhZ3MgYWRkZWQsICR7dmFsaWRNYXRjaGVkVGFncy5sZW5ndGh9IGV4aXN0aW5nIHRhZ3MgbWF0Y2hlZGAsXG4gICAgICAgICAgICAgICAgdGFnczogYWxsVGFncy5tYXAodGFnID0+IGAjJHt0YWd9YCkgLy8gQWRkICMgYmFjayBmb3IgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgbm90ZSB0YWdzOicsIGVycm9yKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InO1xuICAgICAgICAgICAgbmV3IE5vdGljZSgnRXJyb3IgdXBkYXRpbmcgdGFncycpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRmFpbGVkIHRvIHVwZGF0ZSB0YWdzOiAke2Vycm9yTWVzc2FnZX1gXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBleGlzdGluZyB0YWdzXG4gICAgICovXG4gICAgc3RhdGljIGdldEFsbFRhZ3MoYXBwOiBhbnkpOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IHRhZ3MgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgICAgYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Q2FjaGVkRmlsZXMoKS5mb3JFYWNoKChmaWxlUGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldENhY2hlKGZpbGVQYXRoKTtcbiAgICAgICAgICAgIGlmIChjYWNoZT8uZnJvbnRtYXR0ZXI/LnRhZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlVGFncyA9IHRoaXMuZ2V0RXhpc3RpbmdUYWdzKGNhY2hlLmZyb250bWF0dGVyKTtcbiAgICAgICAgICAgICAgICBmaWxlVGFncy5mb3JFYWNoKHRhZyA9PiB0YWdzLmFkZCh0YWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRhZ3MpLnNvcnQoKTtcbiAgICB9XG59Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUEsdUJBQTZHOzs7QUNXdEcsSUFBSztBQUFMLFVBQUssdUJBQUw7QUFDSCxxQ0FBVTtBQUNWLG9DQUFTO0FBQUEsR0FGRDs7O0FDVEwsMkJBQThCO0FBQUEsRUFJakMsWUFBWSxRQUEwQjtBQUNsQyxTQUFLLFdBQVcsT0FBTyxTQUFTO0FBQ2hDLFNBQUssWUFBWSxPQUFPLFVBQVU7QUFBQTtBQUFBLEVBRzVCLGlCQUFnQztBQUN0QyxRQUFJLENBQUMsS0FBSyxVQUFVO0FBQ2hCLGFBQU87QUFBQTtBQUVYLFFBQUksQ0FBQyxLQUFLLFdBQVc7QUFDakIsYUFBTztBQUFBO0FBR1gsUUFBSTtBQUNBLFVBQUksSUFBSSxLQUFLO0FBQUEsYUFDVCxHQUFOO0FBQ0UsYUFBTztBQUFBO0FBR1gsV0FBTztBQUFBO0FBQUEsRUFHRCxZQUFZLEtBQXNCO0FBRXhDLFVBQU0sV0FBVztBQUNqQixXQUFPLFNBQVMsS0FBSztBQUFBO0FBQUEsRUFHZixhQUFhLE1BQTBCO0FBQzdDLFVBQU0sZ0JBQTBCO0FBQ2hDLFVBQU0sU0FBbUI7QUFFekIsZUFBVyxPQUFPLE1BQU07QUFDcEIsVUFBSSxDQUFDLEtBQUssWUFBWSxNQUFNO0FBQ3hCLGVBQU8sS0FBSyx1QkFBdUI7QUFDbkM7QUFBQTtBQUVKLG9CQUFjLEtBQUs7QUFBQTtBQUd2QixRQUFJLE9BQU8sU0FBUyxHQUFHO0FBQ25CLFlBQU0sSUFBSSxNQUFNO0FBQUEsRUFBMkIsT0FBTyxLQUFLO0FBQUE7QUFHM0QsUUFBSSxjQUFjLFdBQVcsR0FBRztBQUM1QixZQUFNLElBQUksTUFBTTtBQUFBO0FBR3BCLFdBQU87QUFBQTtBQUFBLEVBR0Qsd0JBQXdCLFVBQTBCO0FBQ3hELFlBQVEsSUFBSSxpQkFBaUI7QUFHN0IsVUFBTSxvQkFBb0I7QUFDMUIsVUFBTSxnQkFBZ0IsU0FBUyxNQUFNO0FBQ3JDLFFBQUksZUFBZTtBQUNmLGNBQVEsSUFBSSxpQ0FBaUMsY0FBYztBQUMzRCxhQUFPLGNBQWM7QUFBQTtBQUl6QixVQUFNLFlBQVk7QUFDbEIsVUFBTSxZQUFZLFNBQVMsTUFBTTtBQUNqQyxRQUFJLFdBQVc7QUFDWCxjQUFRLElBQUksMEJBQTBCLFVBQVU7QUFDaEQsYUFBTyxVQUFVO0FBQUE7QUFHckIsVUFBTSxJQUFJLE1BQU07QUFBQTtBQUFBLEVBR1YsWUFBWSxTQUFpQixjQUFnQztBQUNuRSxXQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQVdiLGFBQWEsS0FBSztBQUFBO0FBQUE7QUFBQSxFQUdsQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFTWSxjQUFjLFVBQStCO0FBQ25ELFFBQUk7QUFDQSxjQUFRLElBQUk7QUFHWixZQUFNLGNBQWMsS0FBSyx3QkFBd0I7QUFDakQsY0FBUSxJQUFJLDJCQUEyQjtBQUd2QyxZQUFNLFNBQVMsS0FBSyxNQUFNO0FBQzFCLGNBQVEsSUFBSSxnQkFBZ0I7QUFFNUIsVUFBSSxDQUFDLE9BQU8sZUFBZSxDQUFDLE1BQU0sUUFBUSxPQUFPLGdCQUM3QyxDQUFDLE9BQU8sV0FBVyxDQUFDLE1BQU0sUUFBUSxPQUFPLFVBQVU7QUFDbkQsZ0JBQVEsTUFBTSwrQkFBK0I7QUFDN0MsY0FBTSxJQUFJLE1BQU07QUFBQTtBQUlwQixZQUFNLHVCQUF1QixLQUFLLGFBQWEsT0FBTztBQUN0RCxZQUFNLG1CQUFtQixLQUFLLGFBQWEsT0FBTztBQUdsRCxZQUFNLGFBQWEsSUFBSSxJQUFJLENBQUMsR0FBRyxzQkFBc0IsR0FBRztBQUV4RCxhQUFPO0FBQUEsUUFDSCxxQkFBcUI7QUFBQSxRQUNyQixlQUFlLE1BQU0sS0FBSyxJQUFJLElBQUk7QUFBQTtBQUFBLGFBRWpDLE9BQVA7QUFDRSxjQUFRLE1BQU0sMkJBQTJCO0FBQ3pDLGNBQVEsTUFBTSxpQkFBaUI7QUFDL0IsVUFBSSxpQkFBaUIsT0FBTztBQUN4QixjQUFNLElBQUksTUFBTSw0QkFBNEIsTUFBTTtBQUFBO0FBRXRELFlBQU0sSUFBSSxNQUFNO0FBQUE7QUFBQTtBQUFBLEVBSWQsWUFBWSxPQUFnQixXQUEwQjtBQUM1RCxZQUFRLE1BQU0sWUFBWSxjQUFjO0FBQ3hDLFFBQUksaUJBQWlCLE9BQU87QUFDeEIsVUFBSSxNQUFNLFNBQVMsY0FBYztBQUM3QixjQUFNLElBQUksTUFBTSx3QkFBd0I7QUFBQTtBQUU1QyxZQUFNLElBQUksTUFBTSxHQUFHLHFCQUFxQixNQUFNO0FBQUE7QUFFbEQsVUFBTTtBQUFBO0FBQUE7OztBQ25KUCxvQ0FBOEIsZUFBZTtBQUFBLEVBQ2hELFlBQVksUUFBMEI7QUFDbEMsVUFBTTtBQUVOLFNBQUssV0FBVyxLQUFLLGtCQUFrQixPQUFPO0FBQUE7QUFBQSxFQUcxQyxrQkFBa0IsVUFBMEI7QUFDaEQsZUFBVyxTQUFTO0FBRXBCLGVBQVcsU0FBUyxRQUFRLE9BQU87QUFFbkMsUUFBSSxTQUFTLFNBQVMsa0JBQWtCO0FBQ3BDLGlCQUFXLFNBQVMsUUFBUSxpQkFBaUI7QUFBQTtBQUdqRCxRQUFJLENBQUMsU0FBUyxTQUFTLHlCQUF5QjtBQUM1QyxpQkFBVyxHQUFHO0FBQUE7QUFFbEIsV0FBTztBQUFBO0FBQUEsRUFHSCxzQkFBcUM7QUFDekMsVUFBTSxZQUFZLEtBQUs7QUFDdkIsUUFBSTtBQUFXLGFBQU87QUFFdEIsUUFBSTtBQUNBLFlBQU0sTUFBTSxJQUFJLElBQUksS0FBSztBQUN6QixVQUFJLENBQUMsSUFBSSxTQUFTLFNBQVMseUJBQXlCO0FBQ2hELGVBQU87QUFBQTtBQUFBLGFBRVAsR0FBTjtBQUNFLGFBQU87QUFBQTtBQUdYLFdBQU87QUFBQTtBQUFBLFFBR0wsaUJBQXlGO0FBQzNGLFFBQUk7QUFFQSxZQUFNLGtCQUFrQixLQUFLO0FBQzdCLFVBQUksaUJBQWlCO0FBQ2pCLGVBQU87QUFBQSxVQUNILFFBQVEscUJBQXFCO0FBQUEsVUFDN0IsT0FBTztBQUFBLFlBQ0gsTUFBTTtBQUFBLFlBQ04sU0FBUztBQUFBO0FBQUE7QUFBQTtBQUtyQixZQUFNLGFBQWEsSUFBSTtBQUN2QixZQUFNLFlBQVksV0FBVyxNQUFNLFdBQVcsU0FBUztBQUV2RCxjQUFRLElBQUksK0NBQStDLEtBQUs7QUFFaEUsWUFBTSxXQUFXLE1BQU0sTUFBTSxLQUFLLFVBQVU7QUFBQSxRQUN4QyxRQUFRO0FBQUEsUUFDUixTQUFTLEVBQUUsZ0JBQWdCO0FBQUEsUUFDM0IsTUFBTSxLQUFLLFVBQVU7QUFBQSxVQUNqQixPQUFPLEtBQUs7QUFBQSxVQUNaLFVBQVUsQ0FBQztBQUFBLFlBQ1AsTUFBTTtBQUFBLFlBQ04sU0FBUztBQUFBO0FBQUEsVUFFYixZQUFZO0FBQUE7QUFBQSxRQUVoQixRQUFRLFdBQVc7QUFBQTtBQUd2QixtQkFBYTtBQUViLFlBQU0sZUFBZSxNQUFNLFNBQVM7QUFDcEMsY0FBUSxJQUFJLDRCQUE0QjtBQUV4QyxVQUFJLENBQUMsU0FBUyxJQUFJO0FBQ2QsY0FBTSxJQUFJLE1BQU0sdUJBQXVCLFNBQVM7QUFBQTtBQUdwRCxVQUFJO0FBQ0EsY0FBTSxPQUFPLEtBQUssTUFBTTtBQUN4QixZQUFJLENBQUMsS0FBSyxXQUFXLENBQUMsTUFBTSxRQUFRLEtBQUssVUFBVTtBQUMvQyxnQkFBTSxJQUFJLE1BQU07QUFBQTtBQUFBLGVBRWYsWUFBUDtBQUNFLGdCQUFRLE1BQU0sZ0JBQWdCO0FBQzlCLGNBQU0sSUFBSSxNQUFNO0FBQUE7QUFHcEIsYUFBTyxFQUFFLFFBQVEscUJBQXFCO0FBQUEsYUFDakMsT0FBUDtBQUNFLGNBQVEsTUFBTSxvQ0FBb0M7QUFFbEQsVUFBSSxZQUFpQztBQUFBLFFBQ2pDLE1BQU07QUFBQSxRQUNOLFNBQVM7QUFBQTtBQUdiLFVBQUksaUJBQWlCLE9BQU87QUFDeEIsWUFBSSxNQUFNLFNBQVMsY0FBYztBQUM3QixzQkFBWTtBQUFBLFlBQ1IsTUFBTTtBQUFBLFlBQ04sU0FBUztBQUFBO0FBQUEsbUJBRU4sTUFBTSxRQUFRLFNBQVMsb0JBQW9CO0FBQ2xELHNCQUFZO0FBQUEsWUFDUixNQUFNO0FBQUEsWUFDTixTQUFTO0FBQUE7QUFBQSxtQkFFTixNQUFNLFFBQVEsU0FBUyxlQUFlO0FBQzdDLHNCQUFZO0FBQUEsWUFDUixNQUFNO0FBQUEsWUFDTixTQUFTLGtCQUFrQixNQUFNO0FBQUE7QUFBQSxtQkFFOUIsTUFBTSxRQUFRLFNBQVMscUJBQXFCO0FBQ25ELHNCQUFZO0FBQUEsWUFDUixNQUFNO0FBQUEsWUFDTixTQUFTO0FBQUE7QUFBQTtBQUFBO0FBS3JCLGFBQU87QUFBQSxRQUNILFFBQVEscUJBQXFCO0FBQUEsUUFDN0IsT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBLFFBS2IsWUFBWSxTQUFpQixjQUE4QztBQXJJckY7QUFzSVEsUUFBSTtBQUVBLFlBQU0sa0JBQWtCLEtBQUs7QUFDN0IsVUFBSSxpQkFBaUI7QUFDakIsY0FBTSxJQUFJLE1BQU07QUFBQTtBQUdwQixZQUFNLGFBQWEsSUFBSTtBQUN2QixZQUFNLFlBQVksV0FBVyxNQUFNLFdBQVcsU0FBUztBQUV2RCxZQUFNLFdBQVcsTUFBTSxNQUFNLEtBQUssVUFBVTtBQUFBLFFBQ3hDLFFBQVE7QUFBQSxRQUNSLFNBQVMsRUFBRSxnQkFBZ0I7QUFBQSxRQUMzQixNQUFNLEtBQUssVUFBVTtBQUFBLFVBQ2pCLE9BQU8sS0FBSztBQUFBLFVBQ1osVUFBVTtBQUFBLFlBQ047QUFBQSxjQUNJLE1BQU07QUFBQSxjQUNOLFNBQVM7QUFBQTtBQUFBLFlBRWI7QUFBQSxjQUNJLE1BQU07QUFBQSxjQUNOLFNBQVMsS0FBSyxZQUFZLFNBQVM7QUFBQTtBQUFBO0FBQUEsVUFHM0MsYUFBYTtBQUFBO0FBQUEsUUFFakIsUUFBUSxXQUFXO0FBQUE7QUFHdkIsbUJBQWE7QUFFYixZQUFNLGVBQWUsTUFBTSxTQUFTO0FBQ3BDLGNBQVEsSUFBSSx1QkFBdUI7QUFFbkMsVUFBSSxDQUFDLFNBQVMsSUFBSTtBQUNkLGNBQU0sSUFBSSxNQUFNLGNBQWMsU0FBUyxVQUFVLFNBQVM7QUFBQTtBQUc5RCxVQUFJO0FBQ0EsY0FBTSxPQUFPLEtBQUssTUFBTTtBQUN4QixjQUFNLGdCQUFnQix1QkFBSyxZQUFMLG1CQUFlLE9BQWYsbUJBQW1CLFlBQW5CLG1CQUE0QjtBQUNsRCxZQUFJLENBQUMsZUFBZTtBQUNoQixnQkFBTSxJQUFJLE1BQU07QUFBQTtBQUVwQixlQUFPLEtBQUssY0FBYztBQUFBLGVBQ3JCLFlBQVA7QUFDRSxnQkFBUSxNQUFNLGdCQUFnQixZQUFZLGFBQWE7QUFDdkQsY0FBTSxJQUFJLE1BQU07QUFBQTtBQUFBLGFBRWYsT0FBUDtBQUNFLGFBQU8sS0FBSyxZQUFZLE9BQU87QUFBQTtBQUFBO0FBQUE7OztBQ3RMcEMsb0NBQThCLGVBQWU7QUFBQSxFQUdoRCxZQUFZLFFBQTBCO0FBQ2xDLFVBQU07QUFQZDtBQVFRLFNBQUssU0FBUyxjQUFPLFdBQVAsbUJBQWUsV0FBVTtBQUFBO0FBQUEsRUFHbkMsc0JBQXFDO0FBQ3pDLFVBQU0sWUFBWSxLQUFLO0FBQ3ZCLFFBQUk7QUFBVyxhQUFPO0FBRXRCLFFBQUksQ0FBQyxLQUFLLFFBQVE7QUFDZCxhQUFPO0FBQUE7QUFHWCxRQUFJLENBQUMsS0FBSyxTQUFTLGNBQWMsU0FBUyxzQkFBc0I7QUFDNUQsYUFBTztBQUFBO0FBR1gsV0FBTztBQUFBO0FBQUEsUUFHTCxpQkFBeUY7QUExQm5HO0FBMkJRLFFBQUk7QUFDQSxZQUFNLGtCQUFrQixLQUFLO0FBQzdCLFVBQUksaUJBQWlCO0FBQ2pCLGVBQU87QUFBQSxVQUNILFFBQVEscUJBQXFCO0FBQUEsVUFDN0IsT0FBTztBQUFBLFlBQ0gsTUFBTTtBQUFBLFlBQ04sU0FBUztBQUFBO0FBQUE7QUFBQTtBQUtyQixZQUFNLGFBQWEsSUFBSTtBQUN2QixZQUFNLFlBQVksV0FBVyxNQUFNLFdBQVcsU0FBUztBQUV2RCxjQUFRLElBQUkscUNBQXFDLEtBQUs7QUFFdEQsWUFBTSxXQUFXLE1BQU0sTUFBTSxLQUFLLFVBQVU7QUFBQSxRQUN4QyxRQUFRO0FBQUEsUUFDUixTQUFTO0FBQUEsVUFDTCxnQkFBZ0I7QUFBQSxVQUNoQixpQkFBaUIsVUFBVSxLQUFLO0FBQUE7QUFBQSxRQUVwQyxNQUFNLEtBQUssVUFBVTtBQUFBLFVBQ2pCLE9BQU8sS0FBSztBQUFBLFVBQ1osVUFBVTtBQUFBLFlBQ047QUFBQSxjQUNJLE1BQU07QUFBQSxjQUNOLFNBQVM7QUFBQTtBQUFBO0FBQUEsVUFHakIsWUFBWTtBQUFBO0FBQUEsUUFFaEIsUUFBUSxXQUFXO0FBQUE7QUFHdkIsbUJBQWE7QUFFYixZQUFNLGVBQWUsTUFBTSxTQUFTO0FBQ3BDLGNBQVEsSUFBSSw0QkFBNEI7QUFFeEMsVUFBSSxDQUFDLFNBQVMsSUFBSTtBQUNkLFlBQUksU0FBUyxXQUFXLEtBQUs7QUFDekIsZ0JBQU0sSUFBSSxNQUFNO0FBQUEsbUJBQ1QsU0FBUyxXQUFXLEtBQUs7QUFDaEMsZ0JBQU0sSUFBSSxNQUFNO0FBQUE7QUFHcEIsWUFBSTtBQUNBLGdCQUFNLFlBQVksS0FBSyxNQUFNO0FBQzdCLGdCQUFNLElBQUksTUFBTSxpQkFBVSxVQUFWLG1CQUFpQixZQUFXLFVBQVUsV0FBVyxjQUFjLFNBQVM7QUFBQSxpQkFDcEYsR0FBTjtBQUNFLGdCQUFNLElBQUksTUFBTSxjQUFjLFNBQVMsV0FBVztBQUFBO0FBQUE7QUFLMUQsWUFBTSxPQUFPLEtBQUssTUFBTTtBQUN4QixVQUFJLENBQUMsS0FBSyxXQUFXLENBQUMsTUFBTSxRQUFRLEtBQUssVUFBVTtBQUMvQyxjQUFNLElBQUksTUFBTTtBQUFBO0FBR3BCLGFBQU8sRUFBRSxRQUFRLHFCQUFxQjtBQUFBLGFBQ2pDLE9BQVA7QUFDRSxVQUFJLFlBQWlDO0FBQUEsUUFDakMsTUFBTTtBQUFBLFFBQ04sU0FBUztBQUFBO0FBR2IsVUFBSSxpQkFBaUIsT0FBTztBQUN4QixZQUFJLE1BQU0sU0FBUyxjQUFjO0FBQzdCLHNCQUFZO0FBQUEsWUFDUixNQUFNO0FBQUEsWUFDTixTQUFTO0FBQUE7QUFBQSxtQkFFTixNQUFNLFFBQVEsU0FBUyxvQkFBb0I7QUFDbEQsc0JBQVk7QUFBQSxZQUNSLE1BQU07QUFBQSxZQUNOLFNBQVM7QUFBQTtBQUFBLG1CQUVOLE1BQU0sUUFBUSxTQUFTLDBCQUEwQjtBQUN4RCxzQkFBWTtBQUFBLFlBQ1IsTUFBTTtBQUFBLFlBQ04sU0FBUztBQUFBO0FBQUEsbUJBRU4sTUFBTSxRQUFRLFNBQVMsMkJBQTJCO0FBQ3pELHNCQUFZO0FBQUEsWUFDUixNQUFNO0FBQUEsWUFDTixTQUFTO0FBQUE7QUFBQSxlQUVWO0FBQ0gsc0JBQVk7QUFBQSxZQUNSLE1BQU07QUFBQSxZQUNOLFNBQVMsVUFBVSxNQUFNO0FBQUE7QUFBQTtBQUFBO0FBS3JDLGNBQVEsTUFBTSx5QkFBeUI7QUFDdkMsYUFBTztBQUFBLFFBQ0gsUUFBUSxxQkFBcUI7QUFBQSxRQUM3QixPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFLYixZQUFZLFNBQWlCLGNBQThDO0FBcklyRjtBQXNJUSxRQUFJO0FBQ0EsWUFBTSxrQkFBa0IsS0FBSztBQUM3QixVQUFJLGlCQUFpQjtBQUNqQixjQUFNLElBQUksTUFBTTtBQUFBO0FBR3BCLFlBQU0sYUFBYSxJQUFJO0FBQ3ZCLFlBQU0sWUFBWSxXQUFXLE1BQU0sV0FBVyxTQUFTO0FBRXZELFlBQU0sV0FBVyxNQUFNLE1BQU0sS0FBSyxVQUFVO0FBQUEsUUFDeEMsUUFBUTtBQUFBLFFBQ1IsU0FBUztBQUFBLFVBQ0wsZ0JBQWdCO0FBQUEsVUFDaEIsaUJBQWlCLFVBQVUsS0FBSztBQUFBO0FBQUEsUUFFcEMsTUFBTSxLQUFLLFVBQVU7QUFBQSxVQUNqQixPQUFPLEtBQUs7QUFBQSxVQUNaLFVBQVU7QUFBQSxZQUNOO0FBQUEsY0FDSSxNQUFNO0FBQUEsY0FDTixTQUFTO0FBQUE7QUFBQSxZQUViO0FBQUEsY0FDSSxNQUFNO0FBQUEsY0FDTixTQUFTLEtBQUssWUFBWSxTQUFTO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFJL0MsUUFBUSxXQUFXO0FBQUE7QUFHdkIsbUJBQWE7QUFFYixZQUFNLGVBQWUsTUFBTSxTQUFTO0FBQ3BDLGNBQVEsSUFBSSx1QkFBdUI7QUFFbkMsVUFBSSxDQUFDLFNBQVMsSUFBSTtBQUNkLFlBQUk7QUFDQSxnQkFBTSxZQUFZLEtBQUssTUFBTTtBQUM3QixnQkFBTSxJQUFJLE1BQU0saUJBQVUsVUFBVixtQkFBaUIsWUFBVyxVQUFVLFdBQVcsY0FBYyxTQUFTO0FBQUEsaUJBQ3BGLEdBQU47QUFDRSxnQkFBTSxJQUFJLE1BQU0sY0FBYyxTQUFTLFVBQVUsU0FBUztBQUFBO0FBQUE7QUFJbEUsWUFBTSxPQUFPLEtBQUssTUFBTTtBQUN4QixVQUFJLENBQUMsS0FBSyxXQUFXLENBQUMsa0JBQUssUUFBUSxPQUFiLG1CQUFpQixZQUFqQixtQkFBMEIsVUFBUztBQUNyRCxjQUFNLElBQUksTUFBTTtBQUFBO0FBR3BCLGFBQU8sS0FBSyxjQUFjLEtBQUssUUFBUSxHQUFHLFFBQVE7QUFBQSxhQUM3QyxPQUFQO0FBQ0UsYUFBTyxLQUFLLFlBQVksT0FBTztBQUFBO0FBQUE7QUFBQTs7O0FDMUwzQyxzQkFBZ0Q7QUFRekMscUJBQWU7QUFBQSxTQUtYLFlBQVksS0FBc0I7QUFDckMsVUFBTSxXQUFXO0FBQ2pCLFdBQU8sU0FBUyxLQUFLO0FBQUE7QUFBQSxTQU1sQixhQUFhLE1BQXdEO0FBQ3hFLFVBQU0sUUFBa0I7QUFDeEIsVUFBTSxVQUFvQjtBQUUxQixlQUFXLE9BQU8sTUFBTTtBQUNwQixVQUFJLEtBQUssWUFBWSxNQUFNO0FBQ3ZCLGNBQU0sS0FBSztBQUFBLGFBQ1I7QUFDSCxnQkFBUSxLQUFLO0FBQUE7QUFBQTtBQUlyQixXQUFPLEVBQUUsT0FBTztBQUFBO0FBQUEsU0FNYixnQkFBZ0IsYUFBZ0Q7QUFDbkUsUUFBSSxDQUFDLGVBQWUsQ0FBQyxZQUFZLE1BQU07QUFDbkMsYUFBTztBQUFBO0FBSVgsUUFBSSxPQUFpQjtBQUNyQixRQUFJLE1BQU0sUUFBUSxZQUFZLE9BQU87QUFDakMsYUFBTyxZQUFZO0FBQUEsZUFDWixPQUFPLFlBQVksU0FBUyxVQUFVO0FBQzdDLGFBQU8sQ0FBQyxZQUFZO0FBQUE7QUFJeEIsVUFBTSxFQUFFLE9BQU8sWUFBWSxLQUFLLGFBQWE7QUFDN0MsUUFBSSxRQUFRLFNBQVMsR0FBRztBQUNwQixjQUFRLEtBQUssc0NBQXNDO0FBQUE7QUFHdkQsV0FBTztBQUFBO0FBQUEsU0FNSixVQUFVLGNBQXdCLFNBQTZCO0FBQ2xFLFVBQU0sRUFBRSxPQUFPLGtCQUFrQixLQUFLLGFBQWE7QUFDbkQsVUFBTSxFQUFFLE9BQU8sYUFBYSxLQUFLLGFBQWE7QUFFOUMsVUFBTSxVQUFVLENBQUMsR0FBRyxlQUFlLEdBQUc7QUFDdEMsV0FBTyxDQUFDLEdBQUcsSUFBSSxJQUFJLFVBQVU7QUFBQTtBQUFBLFNBTTFCLFVBQVUsS0FBcUI7QUFDbEMsVUFBTSxJQUFJO0FBQ1YsVUFBTSxlQUFlLElBQUksV0FBVyxPQUFPLE1BQU0sSUFBSTtBQUVyRCxRQUFJLENBQUMsS0FBSyxZQUFZLGVBQWU7QUFDakMsWUFBTSxJQUFJLE1BQU0sdUJBQXVCO0FBQUE7QUFHM0MsV0FBTztBQUFBO0FBQUEsZUFNRSxVQUNULEtBQ0EsTUFDMkI7QUFDM0IsUUFBSTtBQUVBLFlBQU0sVUFBVSxNQUFNLElBQUksTUFBTSxLQUFLO0FBR3JDLFVBQUksQ0FBQyxRQUFRLFdBQVcsVUFBVTtBQUM5QixlQUFPO0FBQUEsVUFDSCxTQUFTO0FBQUEsVUFDVCxTQUFTO0FBQUE7QUFBQTtBQUlqQixZQUFNLG1CQUFtQixRQUFRLFFBQVEsU0FBUztBQUNsRCxVQUFJLHFCQUFxQixJQUFJO0FBQ3pCLGVBQU87QUFBQSxVQUNILFNBQVM7QUFBQSxVQUNULFNBQVM7QUFBQTtBQUFBO0FBS2pCLFlBQU0sY0FBYyxRQUFRLE1BQU0sR0FBRztBQUNyQyxZQUFNLG1CQUFtQixRQUFRLE1BQU07QUFHdkMsWUFBTSxRQUFRLFlBQVksTUFBTTtBQUNoQyxZQUFNLFdBQVc7QUFDakIsVUFBSSxjQUFjO0FBQ2xCLFVBQUksWUFBWTtBQUVoQixpQkFBVyxRQUFRLE9BQU87QUFDdEIsWUFBSSxLQUFLLE9BQU8sV0FBVyxVQUFVO0FBQ2pDLHNCQUFZO0FBQ1osbUJBQVMsS0FBSztBQUNkLHdCQUFjO0FBQ2Q7QUFBQTtBQUdKLFlBQUksYUFBYTtBQUNiLGNBQUksS0FBSyxPQUFPLFdBQVcsUUFBUSxLQUFLLE9BQU8sV0FBVyxRQUFRO0FBQzlEO0FBQUEsaUJBQ0c7QUFDSCwwQkFBYztBQUFBO0FBQUE7QUFJdEIsWUFBSSxDQUFDLGFBQWE7QUFDZCxtQkFBUyxLQUFLO0FBQUE7QUFBQTtBQUt0QixVQUFJLENBQUMsV0FBVztBQUNaLGlCQUFTLEtBQUs7QUFBQTtBQUlsQixZQUFNLGFBQWE7QUFBQSxFQUFRLFNBQVMsS0FBSyxRQUFRO0FBR2pELFlBQU0sSUFBSSxNQUFNLE9BQU8sTUFBTTtBQUc3QixZQUFNLElBQUksY0FBYyxRQUFRLFdBQVc7QUFDM0MsWUFBTSxJQUFJLFFBQVEsYUFBVyxXQUFXLFNBQVM7QUFHakQsVUFBSSxVQUFVLFFBQVEsYUFBYTtBQUVuQyxhQUFPO0FBQUEsUUFDSCxTQUFTO0FBQUEsUUFDVCxTQUFTO0FBQUEsUUFDVCxNQUFNO0FBQUE7QUFBQSxhQUVMLE9BQVA7QUFDRSxjQUFRLE1BQU0sd0JBQXdCO0FBQ3RDLFlBQU0sZUFBZSxpQkFBaUIsUUFBUSxNQUFNLFVBQVU7QUFDOUQsVUFBSSx1QkFBTztBQUNYLGFBQU87QUFBQSxRQUNILFNBQVM7QUFBQSxRQUNULFNBQVMseUJBQXlCO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFRakMsZUFDVCxLQUNBLE1BQ0EsU0FDQSxhQUMyQjtBQTFMbkM7QUEyTFEsUUFBSTtBQUVBLFlBQU0sRUFBRSxPQUFPLGNBQWMsU0FBUyxtQkFBbUIsS0FBSyxhQUFhO0FBQzNFLFlBQU0sRUFBRSxPQUFPLGtCQUFrQixTQUFTLHVCQUF1QixLQUFLLGFBQWE7QUFFbkYsVUFBSSxlQUFlLFNBQVMsS0FBSyxtQkFBbUIsU0FBUyxHQUFHO0FBQzVELGNBQU0sY0FBYyxDQUFDLEdBQUcsZ0JBQWdCLEdBQUc7QUFDM0MsY0FBTSxJQUFJLE1BQU0sNkJBQTZCLFlBQVksS0FBSztBQUFBO0FBQUE7QUFJbEUsWUFBTSxVQUFVLE1BQU0sSUFBSSxNQUFNLEtBQUs7QUFDckMsWUFBTSxjQUFjLFVBQUksY0FBYyxhQUFhLFVBQS9CLG1CQUFzQztBQUcxRCxZQUFNLGVBQWUsS0FBSyxnQkFBZ0I7QUFHMUMsWUFBTSxVQUFVLEtBQUssVUFBVSxjQUFjLENBQUMsR0FBRyxjQUFjLEdBQUcsbUJBQzdELElBQUksU0FBTyxJQUFJLFdBQVcsT0FBTyxJQUFJLFVBQVUsS0FBSztBQUd6RCxVQUFJLGFBQWE7QUFDakIsWUFBTSxXQUFXLFFBQVEsSUFBSSxTQUFPLE9BQU8sT0FBTyxLQUFLO0FBRXZELFVBQUksUUFBUSxXQUFXLFVBQVU7QUFFN0IsY0FBTSxtQkFBbUIsUUFBUSxRQUFRLFNBQVM7QUFDbEQsWUFBSSxxQkFBcUIsSUFBSTtBQUN6QixnQkFBTSxvQkFBb0IsUUFBUSxNQUFNLEdBQUc7QUFDM0MsZ0JBQU0sbUJBQW1CLFFBQVEsTUFBTTtBQUd2QyxjQUFJLGtCQUFrQixTQUFTLFlBQVk7QUFFdkMsa0JBQU0sWUFBWTtBQUNsQix5QkFBYSxrQkFBa0IsUUFDM0IsV0FDQTtBQUFBO0FBQUEsRUFBWSxjQUNaO0FBQUEsaUJBQ0Q7QUFFSCx5QkFBYSxvQkFDVDtBQUFBO0FBQUEsRUFBWSxhQUNaO0FBQUE7QUFBQTtBQUFBLGFBR1Q7QUFFSCxxQkFBYTtBQUFBO0FBQUEsRUFBZTtBQUFBO0FBQUE7QUFBQSxFQUFvQjtBQUFBO0FBSXBELFlBQU0sSUFBSSxNQUFNLE9BQU8sTUFBTTtBQUc3QixZQUFNLElBQUksY0FBYyxRQUFRLFdBQVc7QUFDM0MsWUFBTSxJQUFJLFFBQVEsYUFBVyxXQUFXLFNBQVM7QUFHakQsVUFBSSxVQUFVLFFBQVEsYUFBYTtBQUVuQyxhQUFPO0FBQUEsUUFDSCxTQUFTO0FBQUEsUUFDVCxTQUFTLDhCQUE4QixhQUFhLDBCQUEwQixpQkFBaUI7QUFBQSxRQUMvRixNQUFNLFFBQVEsSUFBSSxTQUFPLElBQUk7QUFBQTtBQUFBLGFBRTVCLE9BQVA7QUFDRSxjQUFRLE1BQU0sNkJBQTZCO0FBQzNDLFlBQU0sZUFBZSxpQkFBaUIsUUFBUSxNQUFNLFVBQVU7QUFDOUQsVUFBSSx1QkFBTztBQUNYLGFBQU87QUFBQSxRQUNILFNBQVM7QUFBQSxRQUNULFNBQVMsMEJBQTBCO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0FReEMsV0FBVyxLQUFvQjtBQUNsQyxVQUFNLE9BQU8sSUFBSTtBQUNqQixRQUFJLGNBQWMsaUJBQWlCLFFBQVEsQ0FBQyxhQUFxQjtBQTlRekU7QUErUVksWUFBTSxRQUFRLElBQUksY0FBYyxTQUFTO0FBQ3pDLFVBQUkscUNBQU8sZ0JBQVAsbUJBQW9CLE1BQU07QUFDMUIsY0FBTSxXQUFXLEtBQUssZ0JBQWdCLE1BQU07QUFDNUMsaUJBQVMsUUFBUSxTQUFPLEtBQUssSUFBSTtBQUFBO0FBQUE7QUFHekMsV0FBTyxNQUFNLEtBQUssTUFBTTtBQUFBO0FBQUE7OztBTHRRaEMsSUFBTSxtQkFBcUM7QUFBQSxFQUN2QyxhQUFhO0FBQUEsRUFDYixlQUFlO0FBQUEsRUFDZixZQUFZO0FBQUEsRUFDWixlQUFlO0FBQUEsRUFDZixhQUFhO0FBQUEsRUFDYixZQUFZO0FBQUEsRUFDWixZQUFZO0FBQUEsRUFDWixnQkFBZ0I7QUFBQTtBQUdwQixtQ0FBNEMsd0JBQU87QUFBQSxFQUkvQyxZQUFZLEtBQVUsVUFBZTtBQUNqQyxVQUFNLEtBQUs7QUFKZixvQkFBNkI7QUFLekIsU0FBSyxhQUFhLElBQUksZ0JBQWdCO0FBQUEsTUFDbEMsVUFBVSxpQkFBaUI7QUFBQSxNQUMzQixXQUFXLGlCQUFpQjtBQUFBO0FBQUE7QUFBQSxRQUk5QixTQUFTO0FBQ1gsVUFBTSxLQUFLO0FBQ1gsU0FBSztBQUdMLFNBQUssY0FBYyxJQUFJLG1CQUFtQixLQUFLLEtBQUs7QUFHcEQsU0FBSyxXQUFXO0FBQUEsTUFDWixJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixVQUFVLE1BQU0sS0FBSztBQUFBO0FBR3pCLFNBQUssV0FBVztBQUFBLE1BQ1osSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sU0FBUyxDQUFDLEVBQUUsV0FBVyxDQUFDLE9BQU8sVUFBVSxLQUFLO0FBQUEsTUFDOUMsVUFBVSxNQUFNLEtBQUs7QUFBQTtBQUl6QixTQUFLO0FBQUE7QUFBQSxFQUdELGFBQWE7QUFDakIsVUFBTSxNQUFNLFNBQVMsY0FBYztBQUNuQyxRQUFJLEtBQUs7QUFDVCxRQUFJLGNBQWM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF3RmxCLGFBQVMsS0FBSyxZQUFZO0FBQUE7QUFBQSxFQUd0Qix1QkFBdUI7QUFDM0IsVUFBTSxTQUEyQjtBQUFBLE1BQzdCLFVBQVUsS0FBSyxTQUFTLGdCQUFnQixVQUNsQyxLQUFLLFNBQVMsZ0JBQ2QsS0FBSyxTQUFTO0FBQUEsTUFDcEIsUUFBUSxLQUFLLFNBQVM7QUFBQSxNQUN0QixXQUFXLEtBQUssU0FBUyxnQkFBZ0IsVUFDbkMsS0FBSyxTQUFTLGFBQ2QsS0FBSyxTQUFTO0FBQUE7QUFHeEIsU0FBSyxhQUFhLEtBQUssU0FBUyxnQkFBZ0IsVUFDMUMsSUFBSSxnQkFBZ0IsVUFDcEIsSUFBSSxnQkFBZ0I7QUFBQTtBQUFBLFFBR3hCLGVBQWU7QUFDakIsVUFBTSxjQUFjLE1BQU0sS0FBSztBQUcvQixRQUFJLGVBQWUsWUFBWSxnQkFBZ0IsVUFBVTtBQUNyRCxrQkFBWSxjQUFjO0FBQzFCLGtCQUFZLGdCQUFnQixZQUFZO0FBQ3hDLGtCQUFZLGFBQWEsWUFBWTtBQUNyQyxhQUFPLFlBQVk7QUFDbkIsYUFBTyxZQUFZO0FBQUE7QUFHdkIsU0FBSyxXQUFXLE9BQU8sT0FBTyxJQUFJLGtCQUFrQjtBQUFBO0FBQUEsUUFHbEQsZUFBZTtBQUNqQixVQUFNLEtBQUssU0FBUyxLQUFLO0FBQ3pCLFNBQUs7QUFBQTtBQUFBLFFBR0gsaUJBQXlFO0FBQzNFLFdBQU8sS0FBSyxXQUFXO0FBQUE7QUFBQSxRQUdyQixnQkFBZ0I7QUFDbEIsVUFBTSxhQUFhLEtBQUssSUFBSSxVQUFVO0FBQ3RDLFFBQUksQ0FBQyxZQUFZO0FBQ2IsVUFBSSx3QkFBTztBQUNYO0FBQUE7QUFHSixRQUFJO0FBQ0EsWUFBTSxTQUFTLE1BQU0sU0FBUyxVQUFVLEtBQUssS0FBSztBQUNsRCxVQUFJLE9BQU8sU0FBUztBQUNoQixjQUFNLE9BQU8sS0FBSyxJQUFJLFVBQVUsb0JBQW9CO0FBQ3BELFlBQUksOEJBQU0sZUFBYyxVQUFVO0FBQzlCLGVBQUssT0FBTztBQUFBO0FBR2hCLGFBQUssSUFBSSxNQUFNLFFBQVEsVUFBVTtBQUNqQyxZQUFJLHdCQUFPO0FBQUEsYUFDUjtBQUNILFlBQUksd0JBQU8sT0FBTztBQUFBO0FBSXRCLGlCQUFXLE1BQU07QUFDYixhQUFLLElBQUksVUFBVSxRQUFRLGFBQWE7QUFBQSxTQUN6QztBQUFBLGFBQ0UsT0FBUDtBQUNFLGNBQVEsTUFBTSx3QkFBd0I7QUFDdEMsWUFBTSxVQUFVLGlCQUFpQixRQUFRLE1BQU0sVUFBVTtBQUN6RCxVQUFJLHdCQUFPLHdCQUF3QjtBQUFBO0FBQUE7QUFBQSxRQUlyQyxxQkFBcUI7QUFDdkIsVUFBTSxhQUFhLEtBQUssSUFBSSxVQUFVO0FBQ3RDLFFBQUksQ0FBQyxZQUFZO0FBQ2IsVUFBSSx3QkFBTztBQUNYO0FBQUE7QUFHSixRQUFJO0FBQ0EsWUFBTSxVQUFVLE1BQU0sS0FBSyxJQUFJLE1BQU0sS0FBSztBQUMxQyxVQUFJLENBQUMsUUFBUSxRQUFRO0FBQ2pCLFlBQUksd0JBQU87QUFDWDtBQUFBO0FBR0osWUFBTSxlQUFlLFNBQVMsV0FBVyxLQUFLO0FBQzlDLFVBQUksd0JBQU87QUFFWCxjQUFRLElBQUksK0JBQStCO0FBQUEsUUFDdkMsYUFBYSxLQUFLLFNBQVM7QUFBQSxRQUMzQixlQUFlLFFBQVE7QUFBQSxRQUN2QixtQkFBbUIsYUFBYTtBQUFBO0FBR3BDLFlBQU0sV0FBVyxNQUFNLEtBQUssV0FBVyxZQUFZLFNBQVM7QUFDNUQsWUFBTSxTQUFTLE1BQU0sU0FBUyxlQUMxQixLQUFLLEtBQ0wsWUFDQSxTQUFTLGNBQWMsTUFBTSxHQUFHLEtBQUssU0FBUyxhQUM5QyxTQUFTLG9CQUFvQixNQUFNLEdBQUcsS0FBSyxTQUFTO0FBR3hELFVBQUksT0FBTyxTQUFTO0FBQ2hCLGNBQU0sT0FBTyxLQUFLLElBQUksVUFBVSxvQkFBb0I7QUFDcEQsWUFBSSw4QkFBTSxlQUFjLFVBQVU7QUFDOUIsZUFBSyxPQUFPO0FBQUE7QUFFaEIsWUFBSSx3QkFBTyxPQUFPO0FBQUEsYUFDZjtBQUNILFlBQUksd0JBQU87QUFBQTtBQUFBLGFBRVYsT0FBUDtBQUNFLGNBQVEsTUFBTSxnQ0FBZ0M7QUFDOUMsWUFBTSxVQUFVLGlCQUFpQixRQUFRLE1BQU0sVUFBVTtBQUN6RCxVQUFJLHdCQUFPLHlCQUF5QjtBQUFBO0FBQUE7QUFBQSxFQUk1QyxXQUFXO0FBQ1AsVUFBTSxRQUFRLFNBQVMsZUFBZTtBQUN0QyxRQUFJLE9BQU87QUFDUCxZQUFNO0FBQUE7QUFBQTtBQUFBO0FBS2xCLHVDQUFpQyxrQ0FBaUI7QUFBQSxFQU05QyxZQUFZLEtBQVUsUUFBd0I7QUFDMUMsVUFBTSxLQUFLO0FBTFAsc0JBQXFDO0FBQ3JDLG9CQUErQjtBQUMvQiwyQkFBc0M7QUFJMUMsU0FBSyxTQUFTO0FBQUE7QUFBQSxFQUdsQixVQUFnQjtBQUNaLFVBQU0sRUFBRSxnQkFBZ0I7QUFDeEIsZ0JBQVk7QUFFWixRQUFJLHlCQUFRLGFBQ1AsUUFBUSxtQkFDUixRQUFRLHlDQUNSLFlBQVksY0FDVCxTQUNLLFdBQVc7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxPQUVaLFNBQVMsS0FBSyxPQUFPLFNBQVMsYUFDOUIsU0FBUyxPQUFPLFVBQVU7QUFDdkIsV0FBSyxPQUFPLFNBQVMsY0FBYztBQUNuQyxZQUFNLEtBQUssT0FBTztBQUNsQixXQUFLO0FBQUE7QUFJckIsUUFBSSxLQUFLLE9BQU8sU0FBUyxnQkFBZ0IsU0FBUztBQUM5QyxXQUFLLHFCQUFxQjtBQUFBLFdBQ3ZCO0FBQ0gsV0FBSyxxQkFBcUI7QUFBQTtBQUc5QixTQUFLLHVCQUF1QjtBQUFBO0FBQUEsRUFHeEIsY0FBYyxRQUF5QyxTQUF3QjtBQUNuRixRQUFJLENBQUMsS0FBSyxtQkFBbUIsQ0FBQyxLQUFLO0FBQVU7QUFFN0MsU0FBSyxnQkFBZ0IsWUFBWSxXQUFXLFdBQVc7QUFDdkQsU0FBSyxnQkFBZ0IsU0FBUztBQUU5QixZQUFRO0FBQUEsV0FDQztBQUNELGFBQUssU0FBUyxRQUFRO0FBQ3RCO0FBQUEsV0FDQztBQUNELGFBQUssU0FBUyxRQUFRLFdBQVc7QUFDakM7QUFBQSxXQUNDO0FBQ0QsYUFBSyxTQUFTLFFBQVEsV0FBVztBQUNqQztBQUFBO0FBQUE7QUFBQSxFQUlKLGlCQUFpQixhQUFnQztBQUNyRCxVQUFNLGdCQUFnQixZQUFZLFVBQVU7QUFFNUMsVUFBTSxjQUFjLElBQUkseUJBQVEsZUFDM0IsUUFBUSxtQkFDUixRQUFRO0FBRWIsVUFBTSxrQkFBa0IsWUFBWSxVQUFVLFVBQVU7QUFDeEQsVUFBTSxTQUFTLElBQUksaUNBQWdCLGlCQUM5QixjQUFjLG1CQUNkLFFBQVEsWUFBWTtBQWxXakM7QUFtV2dCLGFBQU8sY0FBYyxjQUFjLFlBQVk7QUFDL0MsV0FBSyxjQUFjO0FBRW5CLFVBQUk7QUFDQSxjQUFNLFNBQVMsTUFBTSxLQUFLLE9BQU87QUFDakMsWUFBSSxPQUFPLFdBQVcscUJBQXFCLFNBQVM7QUFDaEQsZUFBSyxjQUFjLFdBQVc7QUFBQSxlQUMzQjtBQUNILGVBQUssY0FBYyxTQUFTLGNBQU8sVUFBUCxtQkFBYyxZQUFXO0FBQUE7QUFBQSxlQUVwRCxPQUFQO0FBQ0UsZ0JBQVEsTUFBTSwwQkFBMEI7QUFDeEMsYUFBSyxjQUFjLFNBQVM7QUFBQSxnQkFDOUI7QUFDRSxlQUFPLGNBQWMsbUJBQW1CLFlBQVk7QUFBQTtBQUFBO0FBSWhFLFNBQUssa0JBQWtCLGNBQWMsVUFBVTtBQUMvQyxTQUFLLFdBQVcsS0FBSyxnQkFBZ0I7QUFDckMsU0FBSyxhQUFhO0FBQUE7QUFBQSxFQUdkLHFCQUFxQixhQUFnQztBQUN6RCxVQUFNLE9BQU8sWUFBWTtBQUN6QixTQUFLLFdBQVc7QUFBQSxNQUNaLE1BQU07QUFBQSxNQUNOLEtBQUs7QUFBQTtBQUdULFNBQUssU0FBUztBQUNkLFNBQUssU0FBUztBQUVkLFNBQUssV0FBVztBQUFBLE1BQ1osTUFBTTtBQUFBLE1BQ04sS0FBSztBQUFBO0FBR1QsVUFBTSxPQUFPLEtBQUssU0FBUyxNQUFNLEVBQUUsS0FBSztBQUd4QyxVQUFNLGFBQWEsS0FBSyxTQUFTO0FBQ2pDLGVBQVcsV0FBVyxFQUFFLE1BQU07QUFDOUIsZUFBVyxTQUFTLFFBQVEsRUFBRSxNQUFNO0FBQ3BDLGVBQVcsU0FBUztBQUNwQixlQUFXLFdBQVc7QUFBQSxNQUNsQixNQUFNO0FBQUEsTUFDTixLQUFLO0FBQUE7QUFJVCxVQUFNLGVBQWUsS0FBSyxTQUFTO0FBQ25DLGlCQUFhLFdBQVcsRUFBRSxNQUFNO0FBQ2hDLGlCQUFhLFNBQVMsUUFBUSxFQUFFLE1BQU07QUFHdEMsVUFBTSxjQUFjLEtBQUssU0FBUztBQUNsQyxnQkFBWSxXQUFXLEVBQUUsTUFBTTtBQUMvQixnQkFBWSxTQUFTLFFBQVEsRUFBRSxNQUFNO0FBRXJDLFFBQUkseUJBQVEsYUFDUCxRQUFRLHNCQUNSLFFBQVEsNkNBQ1IsUUFBUSxVQUFRLEtBQ1osZUFBZSwwQkFDZixTQUFTLEtBQUssT0FBTyxTQUFTLGVBQzlCLFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLFdBQUssT0FBTyxTQUFTLGdCQUFnQjtBQUNyQyxZQUFNLEtBQUssT0FBTztBQUFBO0FBRzlCLFFBQUkseUJBQVEsYUFDUCxRQUFRLGNBQ1IsUUFBUSxvREFDUixRQUFRLFVBQVEsS0FDWixlQUFlLFVBQ2YsU0FBUyxLQUFLLE9BQU8sU0FBUyxZQUM5QixTQUFTLE9BQU8sVUFBVTtBQUN2QixXQUFLLE9BQU8sU0FBUyxhQUFhO0FBQ2xDLFlBQU0sS0FBSyxPQUFPO0FBQUE7QUFHOUIsU0FBSyxpQkFBaUI7QUFBQTtBQUFBLEVBR2xCLHFCQUFxQixhQUFnQztBQUN6RCxVQUFNLGNBQWMsZUFBZSxZQUFVO0FBQ3pDLGFBQU8sV0FBVztBQUNsQixhQUFPLFNBQVM7QUFDaEIsYUFBTyxXQUFXO0FBQ2xCLGFBQU8sU0FBUztBQUNoQixhQUFPLFNBQVMsUUFBUTtBQUFBLFFBQ3BCLE1BQU07QUFBQSxRQUNOLEtBQUs7QUFBQTtBQUFBO0FBSWIsUUFBSSx5QkFBUSxhQUNQLFFBQVEsZ0JBQ1IsUUFBUSxhQUNSLFFBQVEsVUFBUSxLQUNaLGVBQWUsOENBQ2YsU0FBUyxLQUFLLE9BQU8sU0FBUyxlQUM5QixTQUFTLE9BQU8sVUFBVTtBQUN2QixXQUFLLE9BQU8sU0FBUyxnQkFBZ0I7QUFDckMsWUFBTSxLQUFLLE9BQU87QUFBQTtBQUc5QixRQUFJLHlCQUFRLGFBQ1AsUUFBUSxXQUNSLFFBQVEseUJBQ1IsUUFBUSxVQUFRLEtBQ1osZUFBZSxVQUNmLFNBQVMsS0FBSyxPQUFPLFNBQVMsYUFDOUIsU0FBUyxPQUFPLFVBQVU7QUFDdkIsV0FBSyxPQUFPLFNBQVMsY0FBYztBQUNuQyxZQUFNLEtBQUssT0FBTztBQUFBO0FBRzlCLFFBQUkseUJBQVEsYUFDUCxRQUFRLGNBQ1IsUUFBUSx3QkFDUixRQUFRLFVBQVEsS0FDWixlQUFlLGlCQUNmLFNBQVMsS0FBSyxPQUFPLFNBQVMsWUFDOUIsU0FBUyxPQUFPLFVBQVU7QUFDdkIsV0FBSyxPQUFPLFNBQVMsYUFBYTtBQUNsQyxZQUFNLEtBQUssT0FBTztBQUFBO0FBRzlCLFNBQUssaUJBQWlCO0FBQUE7QUFBQSxFQUdsQix1QkFBdUIsYUFBZ0M7QUFDM0QsUUFBSSx5QkFBUSxhQUNQLFFBQVEsb0JBQ1IsUUFBUSxpREFDUixVQUFVLFlBQVUsT0FDaEIsVUFBVSxHQUFHLElBQUksR0FDakIsU0FBUyxLQUFLLE9BQU8sU0FBUyxZQUM5QixvQkFDQSxTQUFTLE9BQU8sVUFBVTtBQUN2QixXQUFLLE9BQU8sU0FBUyxhQUFhO0FBQ2xDLFlBQU0sS0FBSyxPQUFPO0FBQUE7QUFHOUIsUUFBSSx5QkFBUSxhQUNQLFFBQVEsd0JBQ1IsUUFBUSw0REFDUixVQUFVLFlBQVUsT0FDaEIsVUFBVSxHQUFHLEdBQUcsR0FDaEIsU0FBUyxLQUFLLE9BQU8sU0FBUyxnQkFDOUIsb0JBQ0EsU0FBUyxPQUFPLFVBQVU7QUFDdkIsV0FBSyxPQUFPLFNBQVMsaUJBQWlCO0FBQ3RDLFlBQU0sS0FBSyxPQUFPO0FBRTlCLGtCQUFZLFNBQVMsTUFBTSxFQUFDLE1BQU07QUFDbEMsWUFBTSxZQUFZLFlBQVksVUFBVTtBQUN4QyxnQkFBVSxXQUFXLEVBQUMsTUFBTTtBQUU1QixZQUFNLFNBQVMsSUFBSSxpQ0FBZ0IsV0FDOUIsY0FBYyxtQkFDZCxTQUFTLGtCQUNULFFBQVEsTUFBTTtBQUNYLGVBQU8sS0FBSyx1Q0FBdUM7QUFBQTtBQUFBO0FBQUE7QUFBQTsiLAogICJuYW1lcyI6IFtdCn0K
